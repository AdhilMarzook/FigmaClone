"use client";

// src/index.ts
import { detectDupes } from "@liveblocks/core";

// src/version.ts
var PKG_NAME = "@liveblocks/react";
var PKG_VERSION = "1.9.7";
var PKG_FORMAT = "esm";

// src/ClientSideSuspense.tsx
import * as React from "react";
function ClientSideSuspense(props) {
  const [mounted, setMounted] = React.useState(false);
  React.useEffect(() => {
    setMounted(true);
  }, []);
  return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: props.fallback }, mounted ? props.children() : props.fallback);
}

// src/factory.tsx
import { shallow } from "@liveblocks/client";
import {
  createAsyncCache,
  deprecateIf,
  errorIf,
  isLiveNode,
  makeEventSource as makeEventSource2,
  stringify as stringify2
} from "@liveblocks/core";
import * as React3 from "react";
import { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector2 } from "use-sync-external-store/shim/with-selector.js";

// src/comments/CommentsRoom.tsx
import { CommentsApiError, makeEventSource, stringify } from "@liveblocks/core";
import { nanoid } from "nanoid";
import React2, {
  createContext,
  useCallback as useCallback3,
  useContext,
  useEffect as useEffect3,
  useMemo
} from "react";
import { useSyncExternalStoreWithSelector } from "use-sync-external-store/shim/with-selector.js";

// src/comments/errors.ts
var CreateThreadError = class extends Error {
  constructor(cause, context) {
    super("Create thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateThreadError";
  }
};
var EditThreadMetadataError = class extends Error {
  constructor(cause, context) {
    super("Edit thread metadata failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditThreadMetadataError";
  }
};
var CreateCommentError = class extends Error {
  constructor(cause, context) {
    super("Create comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateCommentError";
  }
};
var EditCommentError = class extends Error {
  constructor(cause, context) {
    super("Edit comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditCommentError";
  }
};
var DeleteCommentError = class extends Error {
  constructor(cause, context) {
    super("Delete comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteCommentError";
  }
};
var AddReactionError = class extends Error {
  constructor(cause, context) {
    super("Add reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "AddReactionError";
  }
};
var RemoveReactionError = class extends Error {
  constructor(cause, context) {
    super("Remove reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "RemoveReactionError";
  }
};

// src/comments/lib/revalidation.ts
import { useCallback as useCallback2, useEffect as useEffect2, useRef as useRef2 } from "react";

// src/comments/lib/use-is-document-visible.ts
import { useSyncExternalStore } from "use-sync-external-store/shim/index.js";
function useIsDocumentVisible() {
  const isVisible = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
  return isVisible;
}
function subscribe(onStoreChange) {
  document.addEventListener("visibilitychange", onStoreChange);
  return () => {
    document.removeEventListener("visibilitychange", onStoreChange);
  };
}
function getSnapshot() {
  const isDocumentDefined = typeof document !== "undefined";
  return isDocumentDefined ? document.visibilityState === "visible" : true;
}

// src/comments/lib/use-is-online.ts
import { useCallback, useRef } from "react";
import { useSyncExternalStore as useSyncExternalStore2 } from "use-sync-external-store/shim/index.js";
function useIsOnline() {
  const isOnlineRef = useRef(true);
  const subscribe2 = useCallback((onStoreChange) => {
    function handleIsOnline() {
      isOnlineRef.current = true;
      onStoreChange();
    }
    function handleIsOffline() {
      isOnlineRef.current = false;
      onStoreChange();
    }
    window.addEventListener("online", handleIsOnline);
    window.addEventListener("offline", handleIsOffline);
    return () => {
      window.removeEventListener("online", handleIsOnline);
      window.removeEventListener("offline", handleIsOffline);
    };
  }, []);
  const getSnapshot2 = useCallback(() => {
    return isOnlineRef.current;
  }, []);
  const isOnline = useSyncExternalStore2(subscribe2, getSnapshot2, getSnapshot2);
  return isOnline;
}

// src/comments/lib/revalidation.ts
var DEFAULT_ERROR_RETRY_INTERVAL = 5e3;
var DEFAULT_MAX_ERROR_RETRY_COUNT = 5;
var DEFAULT_DEDUPING_INTERVAL = 2e3;
var timestamp = 0;
function useRevalidateCache(manager, fetcher, options = {}) {
  const isOnlineRef = useRef2(true);
  const {
    dedupingInterval = DEFAULT_DEDUPING_INTERVAL,
    errorRetryInterval = DEFAULT_ERROR_RETRY_INTERVAL,
    errorRetryCount = DEFAULT_MAX_ERROR_RETRY_COUNT
  } = options;
  const _revalidateCache = useCallback2(
    async ({
      shouldDedupe,
      retryCount = 0
    }) => {
      let startAt;
      const shouldStartRequest = !manager.getRequest() || !shouldDedupe;
      function deleteActiveRequest() {
        const activeRequest = manager.getRequest();
        if (!activeRequest)
          return;
        if (activeRequest.timestamp !== startAt)
          return;
        manager.setRequest(void 0);
      }
      function handleError() {
        const timeout = ~~((Math.random() + 0.5) * (1 << (retryCount < 8 ? retryCount : 8))) * errorRetryInterval;
        if (retryCount > errorRetryCount)
          return;
        setTimeout(() => {
          void _revalidateCache({
            shouldDedupe: false,
            retryCount: retryCount + 1
          });
        }, timeout);
      }
      if (shouldStartRequest) {
        manager.setRequest({
          fetcher: fetcher(),
          timestamp: ++timestamp
        });
      }
      try {
        let activeRequest = manager.getRequest();
        if (!activeRequest)
          return;
        startAt = activeRequest.timestamp;
        const newData = await activeRequest.fetcher;
        if (shouldStartRequest) {
          setTimeout(deleteActiveRequest, dedupingInterval);
        }
        activeRequest = manager.getRequest();
        if (!activeRequest || activeRequest.timestamp !== startAt)
          return;
        const activeMutation = manager.getMutation();
        if (activeMutation && (activeMutation.startTime > startAt || activeMutation.endTime > startAt || activeMutation.endTime === 0)) {
          return;
        }
        manager.setCache(newData);
      } catch (err) {
        deleteActiveRequest();
        const isVisible = document.visibilityState === "visible";
        const isOnline = isOnlineRef.current;
        if (shouldStartRequest && isVisible && isOnline)
          handleError();
        manager.setError(err);
      }
      return;
    },
    [manager, fetcher, dedupingInterval, errorRetryInterval, errorRetryCount]
  );
  useEffect2(() => {
    function handleIsOnline() {
      isOnlineRef.current = true;
    }
    function handleIsOffline() {
      isOnlineRef.current = false;
    }
    window.addEventListener("online", handleIsOnline);
    window.addEventListener("offline", handleIsOffline);
    return () => {
      window.removeEventListener("online", handleIsOnline);
      window.removeEventListener("offline", handleIsOffline);
    };
  }, []);
  const revalidateCache = useCallback2(
    ({ shouldDedupe }) => {
      return _revalidateCache({ shouldDedupe, retryCount: 0 });
    },
    [_revalidateCache]
  );
  return revalidateCache;
}
function useMutate(manager, revalidateCache) {
  const mutate = useCallback2(
    async (data, options) => {
      const beforeMutationTimestamp = ++timestamp;
      manager.setMutation({
        startTime: beforeMutationTimestamp,
        endTime: 0
      });
      const currentCache = manager.getCache();
      manager.setCache(options.optimisticData);
      let error;
      try {
        await data;
      } catch (err) {
        error = err;
      }
      const activeMutation = manager.getMutation();
      if (activeMutation && beforeMutationTimestamp !== activeMutation.startTime) {
        if (error)
          throw error;
        return;
      }
      if (error) {
        manager.setCache(currentCache);
      }
      manager.setMutation({
        startTime: beforeMutationTimestamp,
        endTime: ++timestamp
      });
      manager.setRequest(void 0);
      void revalidateCache({ shouldDedupe: false });
      if (error)
        throw error;
    },
    [manager, revalidateCache]
  );
  return mutate;
}

// src/comments/CommentsRoom.tsx
var THREAD_ID_PREFIX = "th";
var COMMENT_ID_PREFIX = "cm";
var POLLING_INTERVAL_REALTIME = 3e4;
var POLLING_INTERVAL = 5e3;
function createCommentsRoom(errorEventSource) {
  const store = createClientCacheStore();
  const FetcherContext = createContext(null);
  const RoomManagerContext = createContext(null);
  function getThreads(manager) {
    const threads = manager.getCache();
    if (!threads) {
      throw new Error(
        "Cannot update threads or comments before they are loaded."
      );
    }
    return threads;
  }
  function CommentsRoomProvider({
    room,
    children
  }) {
    const manager = useMemo(() => {
      return createRoomRevalidationManager(room.id, {
        getCache: store.getThreads,
        setCache: store.setThreads
      });
    }, [room.id]);
    const fetcher = React2.useCallback(async () => {
      const options = manager.getRevalidationManagers().filter(([key]) => manager.getReferenceCount(key) > 0).map(([_, manager2]) => manager2.getOptions());
      const responses = await Promise.all(
        options.map(async (option) => {
          return await room.getThreads(option);
        })
      );
      const threads = Array.from(
        new Map(responses.flat().map((thread) => [thread.id, thread])).values()
      );
      return threads;
    }, [room, manager]);
    const revalidateCache = useRevalidateCache(manager, fetcher);
    const status = useSyncExternalStore3(
      room.events.status.subscribe,
      room.getStatus,
      room.getStatus
    );
    const isOnline = useIsOnline();
    const isDocumentVisible = useIsDocumentVisible();
    const refreshInterval = getPollingInterval(
      isOnline,
      isDocumentVisible,
      status === "connected"
    );
    useEffect3(() => {
      let revalidationTimerId;
      function scheduleRevalidation() {
        if (refreshInterval === 0)
          return;
        revalidationTimerId = window.setTimeout(() => {
          if (isOnline && isDocumentVisible && !manager.getError() && manager.getTotalReferenceCount() > 0) {
            void revalidateCache({ shouldDedupe: true }).then(
              scheduleRevalidation
            );
            return;
          }
          scheduleRevalidation();
        }, refreshInterval);
      }
      scheduleRevalidation();
      return () => {
        window.clearTimeout(revalidationTimerId);
      };
    }, [
      revalidateCache,
      refreshInterval,
      isOnline,
      isDocumentVisible,
      manager
    ]);
    useEffect3(() => {
      function handleIsOnline() {
        if (isDocumentVisible) {
          void revalidateCache({ shouldDedupe: true });
        }
      }
      window.addEventListener("online", handleIsOnline);
      return () => {
        window.removeEventListener("online", handleIsOnline);
      };
    }, [revalidateCache, isDocumentVisible]);
    useEffect3(() => {
      function handleVisibilityChange() {
        const isVisible = document.visibilityState === "visible";
        if (isVisible && isOnline) {
          void revalidateCache({ shouldDedupe: true });
        }
      }
      document.addEventListener("visibilitychange", handleVisibilityChange);
      return () => {
        document.removeEventListener(
          "visibilitychange",
          handleVisibilityChange
        );
      };
    }, [revalidateCache, isOnline]);
    useEffect3(() => {
      const unsubscribe = room.events.comments.subscribe(() => {
        void revalidateCache({ shouldDedupe: false });
      });
      return () => {
        unsubscribe();
      };
    }, [room, revalidateCache]);
    return /* @__PURE__ */ React2.createElement(FetcherContext.Provider, { value: fetcher }, /* @__PURE__ */ React2.createElement(RoomManagerContext.Provider, { value: manager }, children));
  }
  function useRoomManager() {
    const manager = useContext(RoomManagerContext);
    if (manager === null) {
      throw new Error("CommentsRoomProvider is missing from the React tree.");
    }
    return manager;
  }
  function getUseThreadsRevalidationManager(options, roomManager) {
    const key = stringify(options);
    const revalidationManager = roomManager.getRevalidationManager(key);
    if (!revalidationManager) {
      const useThreadsRevalidationManager = createUseThreadsRevalidationManager(
        options,
        roomManager
      );
      roomManager.setRevalidationmanager(key, useThreadsRevalidationManager);
      return useThreadsRevalidationManager;
    }
    return revalidationManager;
  }
  function useThreadsFetcher() {
    const fetcher = useContext(FetcherContext);
    if (fetcher === null) {
      throw new Error("CommentsRoomProvider is missing from the React tree.");
    }
    return fetcher;
  }
  function useThreads(room, options = { query: { metadata: {} } }) {
    const key = useMemo(() => stringify(options), [options]);
    const manager = useRoomManager();
    const useThreadsRevalidationManager = getUseThreadsRevalidationManager(
      options,
      manager
    );
    const fetcher = React2.useCallback(
      () => {
        return room.getThreads(options);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render
      [key, room]
    );
    const revalidateCache = useRevalidateCache(
      useThreadsRevalidationManager,
      fetcher
    );
    useEffect3(() => {
      void revalidateCache({ shouldDedupe: true });
    }, [revalidateCache]);
    useEffect3(() => {
      manager.incrementReferenceCount(key);
      return () => {
        manager.decrementReferenceCount(key);
      };
    }, [manager, key]);
    const cache = _useThreads(room, options);
    return cache;
  }
  function useThreadsSuspense(room, options = { query: { metadata: {} } }) {
    const key = useMemo(() => stringify(options), [options]);
    const manager = useRoomManager();
    const useThreadsRevalidationManager = getUseThreadsRevalidationManager(
      options,
      manager
    );
    const fetcher = React2.useCallback(
      () => {
        return room.getThreads(options);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render
      [key, room]
    );
    const revalidateCache = useRevalidateCache(
      useThreadsRevalidationManager,
      fetcher
    );
    useEffect3(() => {
      void revalidateCache({ shouldDedupe: true });
    }, [revalidateCache]);
    useEffect3(() => {
      manager.incrementReferenceCount(key);
      return () => {
        manager.decrementReferenceCount(key);
      };
    }, [manager, key]);
    const cache = _useThreads(room, options);
    if (cache.error) {
      throw cache.error;
    }
    if (cache.isLoading || !cache.threads) {
      throw revalidateCache({
        shouldDedupe: true
      });
    }
    return {
      isLoading: false,
      threads: cache.threads,
      error: cache.error
    };
  }
  function _useThreads(room, options) {
    const manager = useRoomManager();
    const useThreadsRevalidationManager = getUseThreadsRevalidationManager(
      options,
      manager
    );
    return useSyncExternalStoreWithSelector(
      store.subscribe,
      () => store.getThreads(),
      () => store.getThreads(),
      (state) => {
        const isLoading = useThreadsRevalidationManager.getIsLoading();
        if (isLoading) {
          return {
            isLoading: true
          };
        }
        const options2 = useThreadsRevalidationManager.getOptions();
        const error = useThreadsRevalidationManager.getError();
        const filtered = state.filter((thread) => {
          if (thread.roomId !== room.id)
            return false;
          const query = options2.query ?? {};
          for (const key in query.metadata) {
            if (thread.metadata[key] !== query.metadata[key]) {
              return false;
            }
          }
          return true;
        });
        return {
          isLoading: false,
          threads: filtered,
          error
        };
      }
    );
  }
  function useEditThreadMetadata(room) {
    const manager = useRoomManager();
    const fetcher = useThreadsFetcher();
    const revalidate = useRevalidateCache(manager, fetcher);
    const mutate = useMutate(manager, revalidate);
    const editThreadMetadata = useCallback3(
      (options) => {
        const threadId = options.threadId;
        const metadata = "metadata" in options ? options.metadata : {};
        const threads = getThreads(manager);
        const optimisticData = threads.map(
          (thread) => thread.id === threadId ? {
            ...thread,
            metadata: {
              ...thread.metadata,
              ...metadata
            }
          } : thread
        );
        mutate(room.editThreadMetadata({ metadata, threadId }), {
          optimisticData
        }).catch((err) => {
          if (!(err instanceof CommentsApiError)) {
            throw err;
          }
          const error = handleCommentsApiError(err);
          errorEventSource.notify(
            new EditThreadMetadataError(error, {
              roomId: room.id,
              threadId,
              metadata
            })
          );
        });
      },
      [room, mutate, manager]
    );
    return editThreadMetadata;
  }
  function useCreateThread(room) {
    const manager = useRoomManager();
    const fetcher = useThreadsFetcher();
    const revalidate = useRevalidateCache(manager, fetcher);
    const mutate = useMutate(manager, revalidate);
    const createThread = useCallback3(
      (options) => {
        const body = options.body;
        const metadata = "metadata" in options ? options.metadata : {};
        const threads = getThreads(manager);
        const threadId = createThreadId();
        const commentId = createCommentId();
        const now = /* @__PURE__ */ new Date();
        const newComment = {
          id: commentId,
          threadId,
          roomId: room.id,
          createdAt: now,
          type: "comment",
          userId: getCurrentUserId(room),
          body,
          reactions: []
        };
        const newThread = {
          id: threadId,
          type: "thread",
          createdAt: now,
          roomId: room.id,
          metadata,
          comments: [newComment]
        };
        mutate(room.createThread({ threadId, commentId, body, metadata }), {
          optimisticData: [...threads, newThread]
        }).catch((err) => {
          if (!(err instanceof CommentsApiError)) {
            throw err;
          }
          const error = handleCommentsApiError(err);
          errorEventSource.notify(
            new CreateThreadError(error, {
              roomId: room.id,
              threadId,
              commentId,
              body,
              metadata
            })
          );
        });
        return newThread;
      },
      [room, mutate, manager]
    );
    return createThread;
  }
  function useCreateComment(room) {
    const manager = useRoomManager();
    const fetcher = useThreadsFetcher();
    const revalidate = useRevalidateCache(manager, fetcher);
    const mutate = useMutate(manager, revalidate);
    const createComment = useCallback3(
      ({ threadId, body }) => {
        const threads = getThreads(manager);
        const commentId = createCommentId();
        const now = /* @__PURE__ */ new Date();
        const comment = {
          id: commentId,
          threadId,
          roomId: room.id,
          type: "comment",
          createdAt: now,
          userId: getCurrentUserId(room),
          body,
          reactions: []
        };
        const optimisticData = threads.map(
          (thread) => thread.id === threadId ? {
            ...thread,
            comments: [...thread.comments, comment]
          } : thread
        );
        mutate(room.createComment({ threadId, commentId, body }), {
          optimisticData
        }).catch((err) => {
          if (!(err instanceof CommentsApiError)) {
            throw err;
          }
          const error = handleCommentsApiError(err);
          errorEventSource.notify(
            new CreateCommentError(error, {
              roomId: room.id,
              threadId,
              commentId,
              body
            })
          );
        });
        return comment;
      },
      [room, mutate, manager]
    );
    return createComment;
  }
  function useEditComment(room) {
    const manager = useRoomManager();
    const fetcher = useThreadsFetcher();
    const revalidate = useRevalidateCache(manager, fetcher);
    const mutate = useMutate(manager, revalidate);
    const editComment = useCallback3(
      ({ threadId, commentId, body }) => {
        const threads = getThreads(manager);
        const now = /* @__PURE__ */ new Date();
        const optimisticData = threads.map(
          (thread) => thread.id === threadId ? {
            ...thread,
            comments: thread.comments.map(
              (comment) => comment.id === commentId ? {
                ...comment,
                editedAt: now,
                body
              } : comment
            )
          } : thread
        );
        mutate(room.editComment({ threadId, commentId, body }), {
          optimisticData
        }).catch((err) => {
          if (!(err instanceof CommentsApiError)) {
            throw err;
          }
          const error = handleCommentsApiError(err);
          errorEventSource.notify(
            new EditCommentError(error, {
              roomId: room.id,
              threadId,
              commentId,
              body
            })
          );
        });
      },
      [room, mutate, manager]
    );
    return editComment;
  }
  function useDeleteComment(room) {
    const manager = useRoomManager();
    const fetcher = useThreadsFetcher();
    const revalidate = useRevalidateCache(manager, fetcher);
    const mutate = useMutate(manager, revalidate);
    const deleteComment = useCallback3(
      ({ threadId, commentId }) => {
        const threads = getThreads(manager);
        const now = /* @__PURE__ */ new Date();
        const newThreads = [];
        for (const thread of threads) {
          if (thread.id === threadId) {
            const newThread = {
              ...thread,
              comments: thread.comments.map(
                (comment) => comment.id === commentId ? {
                  ...comment,
                  deletedAt: now,
                  body: void 0
                } : comment
              )
            };
            if (newThread.comments.some(
              (comment) => comment.deletedAt === void 0
            )) {
              newThreads.push(newThread);
            }
          } else {
            newThreads.push(thread);
          }
        }
        mutate(room.deleteComment({ threadId, commentId }), {
          optimisticData: newThreads
        }).catch((err) => {
          if (!(err instanceof CommentsApiError)) {
            throw err;
          }
          const error = handleCommentsApiError(err);
          errorEventSource.notify(
            new DeleteCommentError(error, {
              roomId: room.id,
              threadId,
              commentId
            })
          );
        });
      },
      [room, mutate, manager]
    );
    return deleteComment;
  }
  function useAddReaction(room) {
    const manager = useRoomManager();
    const fetcher = useThreadsFetcher();
    const revalidate = useRevalidateCache(manager, fetcher);
    const mutate = useMutate(manager, revalidate);
    const createComment = useCallback3(
      ({ threadId, commentId, emoji }) => {
        const threads = getThreads(manager);
        const now = /* @__PURE__ */ new Date();
        const userId = getCurrentUserId(room);
        const optimisticData = threads.map(
          (thread) => thread.id === threadId ? {
            ...thread,
            comments: thread.comments.map((comment) => {
              if (comment.id !== commentId) {
                return comment;
              }
              let reactions;
              if (comment.reactions.some(
                (reaction) => reaction.emoji === emoji
              )) {
                reactions = comment.reactions.map(
                  (reaction) => reaction.emoji === emoji ? {
                    ...reaction,
                    users: [...reaction.users, { id: userId }]
                  } : reaction
                );
              } else {
                reactions = [
                  ...comment.reactions,
                  {
                    emoji,
                    createdAt: now,
                    users: [{ id: userId }]
                  }
                ];
              }
              return {
                ...comment,
                reactions
              };
            })
          } : thread
        );
        mutate(room.addReaction({ threadId, commentId, emoji }), {
          optimisticData
        }).catch((err) => {
          if (!(err instanceof CommentsApiError)) {
            throw err;
          }
          const error = handleCommentsApiError(err);
          errorEventSource.notify(
            new AddReactionError(error, {
              roomId: room.id,
              threadId,
              commentId,
              emoji
            })
          );
        });
      },
      [room, mutate, manager]
    );
    return createComment;
  }
  function useRemoveReaction(room) {
    const manager = useRoomManager();
    const fetcher = useThreadsFetcher();
    const revalidate = useRevalidateCache(manager, fetcher);
    const mutate = useMutate(manager, revalidate);
    const createComment = useCallback3(
      ({ threadId, commentId, emoji }) => {
        const threads = getThreads(manager);
        const userId = getCurrentUserId(room);
        const optimisticData = threads.map(
          (thread) => thread.id === threadId ? {
            ...thread,
            comments: thread.comments.map((comment) => {
              if (comment.id !== commentId) {
                return comment;
              }
              const reactionIndex = comment.reactions.findIndex(
                (reaction) => reaction.emoji === emoji
              );
              let reactions = comment.reactions;
              if (reactionIndex >= 0 && comment.reactions[reactionIndex].users.some(
                (user) => user.id === userId
              )) {
                if (comment.reactions[reactionIndex].users.length <= 1) {
                  reactions = [...comment.reactions];
                  reactions.splice(reactionIndex, 1);
                } else {
                  reactions[reactionIndex] = {
                    ...reactions[reactionIndex],
                    users: reactions[reactionIndex].users.filter(
                      (user) => user.id !== userId
                    )
                  };
                }
              }
              return {
                ...comment,
                reactions
              };
            })
          } : thread
        );
        mutate(room.removeReaction({ threadId, commentId, emoji }), {
          optimisticData
        }).catch((err) => {
          if (!(err instanceof CommentsApiError)) {
            throw err;
          }
          const error = handleCommentsApiError(err);
          errorEventSource.notify(
            new RemoveReactionError(error, {
              roomId: room.id,
              threadId,
              commentId,
              emoji
            })
          );
        });
      },
      [room, mutate, manager]
    );
    return createComment;
  }
  return {
    CommentsRoomProvider,
    useThreads,
    useThreadsSuspense,
    useEditThreadMetadata,
    useCreateThread,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction
  };
}
function createOptimisticId(prefix) {
  return `${prefix}_${nanoid()}`;
}
function createThreadId() {
  return createOptimisticId(THREAD_ID_PREFIX);
}
function createCommentId() {
  return createOptimisticId(COMMENT_ID_PREFIX);
}
function getCurrentUserId(room) {
  const self = room.getSelf();
  if (self === null || self.id === void 0) {
    return "anonymous";
  } else {
    return self.id;
  }
}
function handleCommentsApiError(err) {
  const message = `Request failed with status ${err.status}: ${err.message}`;
  if (err.details?.error === "FORBIDDEN") {
    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join("\n");
    console.error(detailedMessage);
  }
  return new Error(message);
}
function createRoomRevalidationManager(roomId, {
  getCache,
  setCache
}) {
  let request;
  let error;
  let mutation;
  const revalidationManagerByOptions = /* @__PURE__ */ new Map();
  const referenceCountByOptions = /* @__PURE__ */ new Map();
  return {
    // Cache
    getCache() {
      const threads = getCache();
      const filtered = threads.filter((thread) => thread.roomId === roomId);
      return filtered;
    },
    setCache(value) {
      for (const key of revalidationManagerByOptions.keys()) {
        if (referenceCountByOptions.get(key) === 0) {
          revalidationManagerByOptions.delete(key);
          referenceCountByOptions.delete(key);
        }
      }
      const sorted = value.sort(
        (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      );
      const threads = getCache();
      const newThreads = threads.filter((thread) => thread.roomId !== roomId).concat(sorted);
      setCache(newThreads);
    },
    // Request
    getRequest() {
      return request;
    },
    setRequest(value) {
      request = value;
    },
    // Error
    getError() {
      return error;
    },
    setError(err) {
      error = err;
    },
    // Mutation
    getMutation() {
      return mutation;
    },
    setMutation(info) {
      mutation = info;
    },
    getRevalidationManagers() {
      return Array.from(revalidationManagerByOptions.entries());
    },
    getRevalidationManager(key) {
      return revalidationManagerByOptions.get(key);
    },
    setRevalidationmanager(key, manager) {
      revalidationManagerByOptions.set(key, manager);
    },
    getTotalReferenceCount() {
      return Array.from(referenceCountByOptions.values()).reduce(
        (acc, count) => acc + count,
        0
      );
    },
    incrementReferenceCount(key) {
      const count = referenceCountByOptions.get(key) ?? 0;
      referenceCountByOptions.set(key, count + 1);
    },
    decrementReferenceCount(key) {
      const count = referenceCountByOptions.get(key) ?? 0;
      referenceCountByOptions.set(key, count - 1);
    },
    getReferenceCount(key) {
      return referenceCountByOptions.get(key) ?? 0;
    }
  };
}
function createClientCacheStore() {
  let threads = [];
  const threadsEventSource = makeEventSource();
  return {
    getThreads() {
      return threads;
    },
    setThreads(value) {
      threads = value;
      threadsEventSource.notify(threads);
    },
    subscribe(callback) {
      return threadsEventSource.subscribe(callback);
    }
  };
}
function createUseThreadsRevalidationManager(options, manager) {
  let isLoading = true;
  let request;
  let error;
  return {
    // Cache
    getCache() {
      return void 0;
    },
    setCache(value) {
      const cache = new Map(
        (manager.getCache() ?? []).map((thread) => [thread.id, thread])
      );
      for (const thread of value) {
        cache.set(thread.id, thread);
      }
      manager.setCache(Array.from(cache.values()));
      isLoading = false;
    },
    // Request
    getRequest() {
      return request;
    },
    setRequest(value) {
      request = value;
    },
    // Error
    getError() {
      return error;
    },
    setError(err) {
      error = err;
      isLoading = false;
      const cache = manager.getCache();
      manager.setCache(cache);
    },
    // Mutation
    getMutation() {
      return void 0;
    },
    setMutation(_) {
      return;
    },
    getOptions() {
      return options;
    },
    getIsLoading() {
      return isLoading;
    },
    setIsLoading(value) {
      isLoading = value;
    }
  };
}
function getPollingInterval(isBrowserOnline, isDocumentVisible, isRoomConnected) {
  if (!isBrowserOnline || !isDocumentVisible)
    return;
  if (isRoomConnected)
    return POLLING_INTERVAL_REALTIME;
  return POLLING_INTERVAL;
}

// src/comments/lib/use-debounce.ts
import { useEffect as useEffect4, useRef as useRef3, useState as useState2 } from "react";
var DEFAULT_DELAY = 500;
function useDebounce(value, delay = DEFAULT_DELAY) {
  const timeout = useRef3();
  const [debouncedValue, setDebouncedValue] = useState2(value);
  useEffect4(() => {
    if (delay === false) {
      return;
    }
    if (timeout.current === void 0) {
      setDebouncedValue(value);
    }
    timeout.current = window.setTimeout(() => {
      setDebouncedValue(value);
      timeout.current = void 0;
    }, delay);
    return () => {
      window.clearTimeout(timeout.current);
    };
  }, [value, delay]);
  return debouncedValue;
}

// src/lib/use-async-cache.ts
import { useCallback as useCallback4, useEffect as useEffect5, useMemo as useMemo2, useRef as useRef4 } from "react";
import { useSyncExternalStore as useSyncExternalStore4 } from "use-sync-external-store/shim/index.js";

// src/lib/use-initial.ts
import { useState as useState3 } from "react";
function useInitial(value) {
  return useState3(value)[0];
}

// src/lib/use-async-cache.ts
var INITIAL_ASYNC_STATE = {
  isLoading: false,
  data: void 0,
  error: void 0
};
var noop = () => {
};
function useAsyncCache(cache, key, options) {
  const frozenOptions = useInitial(options);
  const cacheItem = useMemo2(() => {
    if (key === null || !cache) {
      return null;
    }
    const cacheItem2 = cache.create(key);
    void cacheItem2.get();
    return cacheItem2;
  }, [cache, key]);
  const subscribe2 = useCallback4(
    (callback) => cacheItem?.subscribe(callback) ?? noop,
    [cacheItem]
  );
  const getState = useCallback4(
    () => cacheItem?.getState() ?? INITIAL_ASYNC_STATE,
    [cacheItem]
  );
  const revalidate = useCallback4(() => cacheItem?.revalidate(), [cacheItem]);
  const state = useSyncExternalStore4(subscribe2, getState, getState);
  const previousData = useRef4();
  let data = state.data;
  useEffect5(() => {
    previousData.current = { key, data: state.data };
  }, [key, state.data]);
  if (!cacheItem) {
    return {
      isLoading: false,
      data: void 0,
      error: void 0,
      getState,
      revalidate
    };
  }
  if (frozenOptions?.suspense) {
    const error = getState().error;
    if (error) {
      throw error;
    } else if (getState().isLoading) {
      throw new Promise((resolve) => {
        cacheItem.subscribeOnce((state2) => {
          if (!state2.isLoading) {
            resolve();
          }
        });
      });
    }
  }
  if (state.isLoading && frozenOptions?.keepPreviousDataWhileLoading && typeof state.data === "undefined" && previousData.current?.key !== key && typeof previousData.current?.data !== "undefined") {
    data = previousData.current.data;
  }
  return {
    isLoading: state.isLoading,
    data,
    error: state.error,
    getState,
    revalidate
  };
}

// src/lib/use-latest.ts
import { useEffect as useEffect6, useRef as useRef5 } from "react";
function useLatest(value) {
  const ref = useRef5(value);
  useEffect6(() => {
    ref.current = value;
  }, [value]);
  return ref;
}

// src/lib/use-rerender.ts
import { useReducer } from "react";
function useRerender() {
  const [, update] = useReducer(
    // This implementation works by incrementing a hidden counter value that is
    // never consumed. Simply incrementing the counter changes the component's
    // state and, thus, trigger a re-render.
    (x) => x + 1,
    0
  );
  return update;
}

// src/factory.tsx
var noop2 = () => {
};
var identity = (x) => x;
var missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\u2019re ready to upgrade to React 18:

    import { unstable_batchedUpdates } from "react-dom";  // or "react-native"

    <RoomProvider id=${JSON.stringify(
  roomId
)} ... unstable_batchedUpdates={unstable_batchedUpdates}>
      ...
    </RoomProvider>

Why? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;
var superfluous_unstable_batchedUpdates = "You don\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\u2019re on React 18+ already.";
function useSyncExternalStore3(s, gs, gss) {
  return useSyncExternalStoreWithSelector2(s, gs, gss, identity);
}
var STABLE_EMPTY_LIST = Object.freeze([]);
function alwaysEmptyList() {
  return STABLE_EMPTY_LIST;
}
function alwaysNull() {
  return null;
}
function makeMutationContext(room) {
  const errmsg = "This mutation cannot be used until connected to the Liveblocks room";
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(errmsg);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(errmsg);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(errmsg);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
var hasWarnedIfNoResolveUsers = false;
function warnIfNoResolveUsers(usersCache) {
  if (!hasWarnedIfNoResolveUsers && !usersCache && process.env.NODE_ENV !== "production") {
    console.warn(
      "Set the resolveUsers option in createRoomContext to specify user info."
    );
    hasWarnedIfNoResolveUsers = true;
  }
}
var ContextBundle = React3.createContext(null);
function useRoomContextBundle() {
  const bundle = React3.useContext(ContextBundle);
  if (bundle === null) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return bundle;
}
function createRoomContext(client, options) {
  const RoomContext = React3.createContext(null);
  const commentsErrorEventSource = makeEventSource2();
  const { CommentsRoomProvider, ...commentsRoom } = createCommentsRoom(commentsErrorEventSource);
  function RoomProviderOuter(props) {
    const [cache] = React3.useState(
      () => /* @__PURE__ */ new Map()
    );
    const stableEnterRoom = React3.useCallback(
      (roomId, options2) => {
        const cached = cache.get(roomId);
        if (cached)
          return cached;
        const rv = client.enterRoom(
          roomId,
          options2
        );
        const origLeave = rv.leave;
        rv.leave = () => {
          origLeave();
          cache.delete(roomId);
        };
        cache.set(roomId, rv);
        return rv;
      },
      [cache]
    );
    return /* @__PURE__ */ React3.createElement(RoomProviderInner, { ...props, stableEnterRoom });
  }
  function RoomProviderInner(props) {
    const { id: roomId, stableEnterRoom } = props;
    if (process.env.NODE_ENV !== "production") {
      if (!roomId) {
        throw new Error(
          "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
        );
      }
      if (typeof roomId !== "string") {
        throw new Error("RoomProvider id property should be a string.");
      }
      const majorReactVersion = parseInt(React3.version) || 1;
      const oldReactVersion = majorReactVersion < 18;
      errorIf(
        oldReactVersion && props.unstable_batchedUpdates === void 0,
        missing_unstable_batchedUpdates(majorReactVersion, roomId)
      );
      deprecateIf(
        !oldReactVersion && props.unstable_batchedUpdates !== void 0,
        superfluous_unstable_batchedUpdates
      );
    }
    const frozenProps = useInitial({
      initialPresence: props.initialPresence,
      initialStorage: props.initialStorage,
      unstable_batchedUpdates: props.unstable_batchedUpdates,
      autoConnect: props.autoConnect ?? props.shouldInitiallyConnect ?? typeof window !== "undefined"
    });
    const [{ room }, setRoomLeavePair] = React3.useState(
      () => stableEnterRoom(roomId, {
        ...frozenProps,
        autoConnect: false
        // Deliberately using false here on the first render, see below
      })
    );
    React3.useEffect(() => {
      const pair = stableEnterRoom(roomId, frozenProps);
      setRoomLeavePair(pair);
      const { room: room2, leave } = pair;
      if (frozenProps.autoConnect) {
        room2.connect();
      }
      return () => {
        leave();
      };
    }, [roomId, frozenProps, stableEnterRoom]);
    return /* @__PURE__ */ React3.createElement(RoomContext.Provider, { value: room }, /* @__PURE__ */ React3.createElement(CommentsRoomProvider, { room }, /* @__PURE__ */ React3.createElement(
      ContextBundle.Provider,
      {
        value: internalBundle
      },
      props.children
    )));
  }
  function connectionIdSelector(others) {
    return others.map((user) => user.connectionId);
  }
  function useRoom() {
    const room = React3.useContext(RoomContext);
    if (room === null) {
      throw new Error("RoomProvider is missing from the React tree.");
    }
    return room;
  }
  function useStatus() {
    const room = useRoom();
    const subscribe2 = room.events.status.subscribe;
    const getSnapshot2 = room.getStatus;
    const getServerSnapshot = room.getStatus;
    return useSyncExternalStore3(subscribe2, getSnapshot2, getServerSnapshot);
  }
  function useMyPresence() {
    const room = useRoom();
    const subscribe2 = room.events.myPresence.subscribe;
    const getSnapshot2 = room.getPresence;
    const presence = useSyncExternalStore3(subscribe2, getSnapshot2, getSnapshot2);
    const setPresence = room.updatePresence;
    return [presence, setPresence];
  }
  function useUpdateMyPresence() {
    return useRoom().updatePresence;
  }
  function useOthers(selector, isEqual) {
    const room = useRoom();
    const subscribe2 = room.events.others.subscribe;
    const getSnapshot2 = room.getOthers;
    const getServerSnapshot = alwaysEmptyList;
    return useSyncExternalStoreWithSelector2(
      subscribe2,
      getSnapshot2,
      getServerSnapshot,
      selector ?? identity,
      isEqual
    );
  }
  function useOthersConnectionIds() {
    return useOthers(connectionIdSelector, shallow);
  }
  function useOthersMapped(itemSelector, itemIsEqual) {
    const wrappedSelector = React3.useCallback(
      (others) => others.map(
        (other) => [other.connectionId, itemSelector(other)]
      ),
      [itemSelector]
    );
    const wrappedIsEqual = React3.useCallback(
      (a, b) => {
        const eq = itemIsEqual ?? Object.is;
        return a.length === b.length && a.every((atuple, index) => {
          const btuple = b[index];
          return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
        });
      },
      [itemIsEqual]
    );
    return useOthers(wrappedSelector, wrappedIsEqual);
  }
  const NOT_FOUND = Symbol();
  function useOther(connectionId, selector, isEqual) {
    const wrappedSelector = React3.useCallback(
      (others) => {
        const other2 = others.find(
          (other3) => other3.connectionId === connectionId
        );
        return other2 !== void 0 ? selector(other2) : NOT_FOUND;
      },
      [connectionId, selector]
    );
    const wrappedIsEqual = React3.useCallback(
      (prev, curr) => {
        if (prev === NOT_FOUND || curr === NOT_FOUND) {
          return prev === curr;
        }
        const eq = isEqual ?? Object.is;
        return eq(prev, curr);
      },
      [isEqual]
    );
    const other = useOthers(wrappedSelector, wrappedIsEqual);
    if (other === NOT_FOUND) {
      throw new Error(
        `No such other user with connection id ${connectionId} exists`
      );
    }
    return other;
  }
  function useBroadcastEvent() {
    const room = useRoom();
    return React3.useCallback(
      (event, options2 = { shouldQueueEventIfNotReady: false }) => {
        room.broadcastEvent(event, options2);
      },
      [room]
    );
  }
  function useOthersListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    React3.useEffect(
      () => room.events.others.subscribe((event) => savedCallback.current(event)),
      [room, savedCallback]
    );
  }
  function useLostConnectionListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    React3.useEffect(
      () => room.events.lostConnection.subscribe(
        (event) => savedCallback.current(event)
      ),
      [room, savedCallback]
    );
  }
  function useErrorListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    React3.useEffect(
      () => room.events.error.subscribe((e) => savedCallback.current(e)),
      [room, savedCallback]
    );
  }
  function useEventListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    React3.useEffect(() => {
      const listener = (eventData) => {
        savedCallback.current(eventData);
      };
      return room.events.customEvent.subscribe(listener);
    }, [room, savedCallback]);
  }
  function useSelf(maybeSelector, isEqual) {
    const room = useRoom();
    const subscribe2 = room.events.self.subscribe;
    const getSnapshot2 = room.getSelf;
    const selector = maybeSelector ?? identity;
    const wrappedSelector = React3.useCallback(
      (me) => me !== null ? selector(me) : null,
      [selector]
    );
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStoreWithSelector2(
      subscribe2,
      getSnapshot2,
      getServerSnapshot,
      wrappedSelector,
      isEqual
    );
  }
  function useMutableStorageRoot() {
    const room = useRoom();
    const subscribe2 = room.events.storageDidLoad.subscribeOnce;
    const getSnapshot2 = room.getStorageSnapshot;
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStore3(subscribe2, getSnapshot2, getServerSnapshot);
  }
  function useStorageRoot() {
    return [useMutableStorageRoot()];
  }
  function useHistory() {
    return useRoom().history;
  }
  function useUndo() {
    return useHistory().undo;
  }
  function useRedo() {
    return useHistory().redo;
  }
  function useCanUndo() {
    const room = useRoom();
    const subscribe2 = room.events.history.subscribe;
    const canUndo = room.history.canUndo;
    return useSyncExternalStore3(subscribe2, canUndo, canUndo);
  }
  function useCanRedo() {
    const room = useRoom();
    const subscribe2 = room.events.history.subscribe;
    const canRedo = room.history.canRedo;
    return useSyncExternalStore3(subscribe2, canRedo, canRedo);
  }
  function useBatch() {
    return useRoom().batch;
  }
  function useLegacyKey(key) {
    const room = useRoom();
    const rootOrNull = useMutableStorageRoot();
    const rerender = useRerender();
    React3.useEffect(() => {
      if (rootOrNull === null) {
        return;
      }
      const root = rootOrNull;
      let unsubCurr;
      let curr = root.get(key);
      function subscribeToCurr() {
        unsubCurr = isLiveNode(curr) ? room.subscribe(curr, rerender) : void 0;
      }
      function onRootChange() {
        const newValue = root.get(key);
        if (newValue !== curr) {
          unsubCurr?.();
          curr = newValue;
          subscribeToCurr();
          rerender();
        }
      }
      subscribeToCurr();
      rerender();
      const unsubscribeRoot = room.subscribe(root, onRootChange);
      return () => {
        unsubscribeRoot();
        unsubCurr?.();
      };
    }, [rootOrNull, room, key, rerender]);
    if (rootOrNull === null) {
      return null;
    } else {
      return rootOrNull.get(key);
    }
  }
  function useStorage(selector, isEqual) {
    const room = useRoom();
    const rootOrNull = useMutableStorageRoot();
    const wrappedSelector = React3.useCallback(
      (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
      [selector]
    );
    const subscribe2 = React3.useCallback(
      (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,
      [room, rootOrNull]
    );
    const getSnapshot2 = React3.useCallback(() => {
      if (rootOrNull === null) {
        return null;
      } else {
        const root = rootOrNull;
        const imm = root.toImmutable();
        return imm;
      }
    }, [rootOrNull]);
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStoreWithSelector2(
      subscribe2,
      getSnapshot2,
      getServerSnapshot,
      wrappedSelector,
      isEqual
    );
  }
  function ensureNotServerSide() {
    if (typeof window === "undefined") {
      throw new Error(
        "You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr"
      );
    }
  }
  function useSuspendUntilStorageLoaded() {
    const room = useRoom();
    if (room.getStorageSnapshot() !== null) {
      return;
    }
    ensureNotServerSide();
    throw new Promise((res) => {
      room.events.storageDidLoad.subscribeOnce(() => res());
    });
  }
  function useSuspendUntilPresenceLoaded() {
    const room = useRoom();
    if (room.getSelf() !== null) {
      return;
    }
    ensureNotServerSide();
    throw new Promise((res) => {
      room.events.self.subscribeOnce(() => res());
      room.events.status.subscribeOnce(() => res());
    });
  }
  function useMutation(callback, deps) {
    const room = useRoom();
    return React3.useMemo(
      () => {
        return (...args) => (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-return
          room.batch(
            () => (
              // eslint-disable-next-line @typescript-eslint/no-unsafe-return
              callback(
                makeMutationContext(room),
                ...args
              )
            )
          )
        );
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [room, ...deps]
    );
  }
  function useStorageSuspense(selector, isEqual) {
    useSuspendUntilStorageLoaded();
    return useStorage(
      selector,
      isEqual
    );
  }
  function useSelfSuspense(selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useSelf(
      selector,
      isEqual
    );
  }
  function useOthersSuspense(selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useOthers(
      selector,
      isEqual
    );
  }
  function useOthersConnectionIdsSuspense() {
    useSuspendUntilPresenceLoaded();
    return useOthersConnectionIds();
  }
  function useOthersMappedSuspense(itemSelector, itemIsEqual) {
    useSuspendUntilPresenceLoaded();
    return useOthersMapped(itemSelector, itemIsEqual);
  }
  function useOtherSuspense(connectionId, selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useOther(connectionId, selector, isEqual);
  }
  function useLegacyKeySuspense(key) {
    useSuspendUntilStorageLoaded();
    return useLegacyKey(key);
  }
  function useThreads(options2) {
    const room = useRoom();
    return commentsRoom.useThreads(room, options2);
  }
  function useThreadsSuspense(options2) {
    const room = useRoom();
    return commentsRoom.useThreadsSuspense(room, options2);
  }
  function useCreateThread() {
    const room = useRoom();
    return commentsRoom.useCreateThread(room);
  }
  function useEditThreadMetadata() {
    const room = useRoom();
    return commentsRoom.useEditThreadMetadata(room);
  }
  function useAddReaction() {
    const room = useRoom();
    return commentsRoom.useAddReaction(room);
  }
  function useRemoveReaction() {
    const room = useRoom();
    return commentsRoom.useRemoveReaction(room);
  }
  function useCreateComment() {
    const room = useRoom();
    return commentsRoom.useCreateComment(room);
  }
  function useEditComment() {
    const room = useRoom();
    return commentsRoom.useEditComment(room);
  }
  function useDeleteComment() {
    const room = useRoom();
    return commentsRoom.useDeleteComment(room);
  }
  const { resolveUsers, resolveMentionSuggestions } = options ?? {};
  const usersCache = resolveUsers ? createAsyncCache(async (stringifiedOptions) => {
    const users = await resolveUsers(
      JSON.parse(stringifiedOptions)
    );
    return users?.[0];
  }) : void 0;
  function useUser(userId) {
    const room = useRoom();
    const resolverKey = React3.useMemo(
      () => stringify2({ userIds: [userId], roomId: room.id }),
      [userId, room.id]
    );
    const state = useAsyncCache(usersCache, resolverKey);
    React3.useEffect(() => warnIfNoResolveUsers(usersCache), []);
    if (state.isLoading) {
      return {
        isLoading: true
      };
    } else {
      return {
        user: state.data,
        error: state.error,
        isLoading: false
      };
    }
  }
  function useUserSuspense(userId) {
    const room = useRoom();
    const resolverKey = React3.useMemo(
      () => stringify2({ userIds: [userId], roomId: room.id }),
      [userId, room.id]
    );
    const state = useAsyncCache(usersCache, resolverKey, {
      suspense: true
    });
    React3.useEffect(() => warnIfNoResolveUsers(usersCache), []);
    return {
      user: state.data,
      isLoading: false
    };
  }
  const mentionSuggestionsCache = createAsyncCache(
    resolveMentionSuggestions ? (stringifiedOptions) => {
      return resolveMentionSuggestions(
        JSON.parse(stringifiedOptions)
      );
    } : () => Promise.resolve([])
  );
  function useMentionSuggestions(search) {
    const room = useRoom();
    const debouncedSearch = useDebounce(search, 500);
    const resolverKey = React3.useMemo(
      () => debouncedSearch !== void 0 ? stringify2({ text: debouncedSearch, roomId: room.id }) : null,
      [debouncedSearch, room.id]
    );
    const { data } = useAsyncCache(mentionSuggestionsCache, resolverKey, {
      keepPreviousDataWhileLoading: true
    });
    return data;
  }
  const bundle = {
    RoomContext,
    RoomProvider: RoomProviderOuter,
    useRoom,
    useStatus,
    useBatch,
    useBroadcastEvent,
    useOthersListener,
    useLostConnectionListener,
    useErrorListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    // These are just aliases. The passed-in key will define their return values.
    useList: useLegacyKey,
    useMap: useLegacyKey,
    useObject: useLegacyKey,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useUser,
    useCreateThread,
    useEditThreadMetadata,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    suspense: {
      RoomContext,
      RoomProvider: RoomProviderOuter,
      useRoom,
      useStatus,
      useBatch,
      useBroadcastEvent,
      useOthersListener,
      useLostConnectionListener,
      useErrorListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      // Legacy hooks
      useList: useLegacyKeySuspense,
      useMap: useLegacyKeySuspense,
      useObject: useLegacyKeySuspense,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useUser: useUserSuspense,
      useCreateThread,
      useEditThreadMetadata,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction
    }
  };
  const internalBundle = {
    ...bundle,
    hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,
    useMentionSuggestions
  };
  return bundle;
}

// src/index.ts
import { shallow as shallow2 } from "@liveblocks/client";
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);
export {
  ClientSideSuspense,
  createRoomContext,
  shallow2 as shallow,
  useRoomContextBundle
};
//# sourceMappingURL=index.mjs.map