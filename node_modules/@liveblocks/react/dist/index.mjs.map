{"version":3,"sources":["../src/index.ts","../src/version.ts","../src/ClientSideSuspense.tsx","../src/factory.tsx","../src/comments/CommentsRoom.tsx","../src/comments/errors.ts","../src/comments/lib/revalidation.ts","../src/comments/lib/use-is-document-visible.ts","../src/comments/lib/use-is-online.ts","../src/comments/lib/use-debounce.ts","../src/lib/use-async-cache.ts","../src/lib/use-initial.ts","../src/lib/use-latest.ts","../src/lib/use-rerender.ts"],"sourcesContent":["import { detectDupes } from \"@liveblocks/core\";\n\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\nexport { ClientSideSuspense } from \"./ClientSideSuspense\";\nexport type { UseThreadsOptions } from \"./comments/CommentsRoom\";\nexport { createRoomContext, useRoomContextBundle } from \"./factory\";\nexport type {\n  MutationContext,\n  ResolveMentionSuggestionsArgs,\n  ResolveUsersArgs,\n} from \"./types\";\n\n// Re-exports from @liveblocks/client, for convenience\nexport type { Json, JsonObject } from \"@liveblocks/client\";\nexport { shallow } from \"@liveblocks/client\";\n","declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/react\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import type { ReactElement, ReactNode } from \"react\";\nimport * as React from \"react\";\n\ntype Props = {\n  fallback: NonNullable<ReactNode> | null;\n  children: () => ReactNode | undefined;\n};\n\n/**\n * Almost like a normal <Suspense> component, except that for server-side\n * renders, the fallback will be used.\n *\n * The child props will have to be provided in a function, i.e. change:\n *\n *   <Suspense fallback={<Loading />}>\n *     <MyRealComponent a={1} />\n *   </Suspense>\n *\n * To:\n *\n *   <ClientSideSuspense fallback={<Loading />}>\n *     {() => <MyRealComponent a={1} />}\n *   </ClientSideSuspense>\n *\n */\nexport function ClientSideSuspense(props: Props): ReactElement {\n  const [mounted, setMounted] = React.useState(false);\n\n  React.useEffect(() => {\n    // Effects are never executed on the server side. The point of this is to\n    // delay the flipping of this boolean until after hydration has happened.\n    setMounted(true);\n  }, []);\n\n  return (\n    <React.Suspense fallback={props.fallback}>\n      {mounted ? props.children() : props.fallback}\n    </React.Suspense>\n  );\n}\n","import type {\n  BaseUserMeta,\n  BroadcastOptions,\n  Client,\n  History,\n  Json,\n  JsonObject,\n  LiveObject,\n  LostConnectionEvent,\n  LsonObject,\n  OthersEvent,\n  Room,\n  Status,\n  User,\n} from \"@liveblocks/client\";\nimport { shallow } from \"@liveblocks/client\";\nimport type {\n  AsyncCache,\n  BaseMetadata,\n  CommentData,\n  EnterOptions,\n  GetThreadsOptions,\n  RoomEventMessage,\n  ToImmutable,\n} from \"@liveblocks/core\";\nimport {\n  createAsyncCache,\n  deprecateIf,\n  errorIf,\n  isLiveNode,\n  makeEventSource,\n  stringify,\n} from \"@liveblocks/core\";\nimport * as React from \"react\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\n\nimport type {\n  CreateCommentOptions,\n  EditCommentOptions,\n  ThreadsState,\n} from \"./comments/CommentsRoom\";\nimport { createCommentsRoom } from \"./comments/CommentsRoom\";\nimport type { CommentsError } from \"./comments/errors\";\nimport { useDebounce } from \"./comments/lib/use-debounce\";\nimport { useAsyncCache } from \"./lib/use-async-cache\";\nimport { useInitial } from \"./lib/use-initial\";\nimport { useLatest } from \"./lib/use-latest\";\nimport { useRerender } from \"./lib/use-rerender\";\nimport type {\n  InternalRoomContextBundle,\n  MutationContext,\n  OmitFirstArg,\n  PromiseOrNot,\n  ResolveMentionSuggestionsArgs,\n  ResolveUsersArgs,\n  RoomContextBundle,\n  RoomProviderProps,\n  UserState,\n  UserStateSuccess,\n} from \"./types\";\n\nconst noop = () => {};\nconst identity: <T>(x: T) => T = (x) => x;\n\nconst missing_unstable_batchedUpdates = (\n  reactVersion: number,\n  roomId: string\n) =>\n  `We noticed you’re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you’re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(\n      roomId\n    )} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\n\nconst superfluous_unstable_batchedUpdates =\n  \"You don’t need to pass unstable_batchedUpdates to RoomProvider anymore, since you’re on React 18+ already.\";\n\nexport function useSyncExternalStore<Snapshot>(\n  s: (onStoreChange: () => void) => () => void,\n  gs: () => Snapshot,\n  gss: undefined | null | (() => Snapshot)\n): Snapshot {\n  return useSyncExternalStoreWithSelector(s, gs, gss, identity);\n}\n\nconst STABLE_EMPTY_LIST = Object.freeze([]);\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a React.useCallback() wrapper.\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a React.useCallback() wrapper.\nfunction alwaysNull() {\n  return null;\n}\n\nfunction makeMutationContext<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n>(\n  room: Room<TPresence, TStorage, TUserMeta, TRoomEvent>\n): MutationContext<TPresence, TStorage, TUserMeta> {\n  const errmsg =\n    \"This mutation cannot be used until connected to the Liveblocks room\";\n\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(errmsg);\n      }\n      return mutableRoot;\n    },\n\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(errmsg);\n      }\n      return self;\n    },\n\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(errmsg);\n      }\n      return others;\n    },\n\n    setMyPresence: room.updatePresence,\n  };\n}\n\ntype Options<TUserMeta extends BaseUserMeta> = {\n  /**\n   * @beta\n   *\n   * A function that returns user info from user IDs.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => PromiseOrNot<(TUserMeta[\"info\"] | undefined)[] | undefined>;\n\n  /**\n   * @beta\n   *\n   * A function that returns a list of user IDs matching a string.\n   */\n  resolveMentionSuggestions?: (\n    args: ResolveMentionSuggestionsArgs\n  ) => PromiseOrNot<string[]>;\n\n  /**\n   * @internal To point the client to a different Liveblocks server. Only\n   * useful for Liveblocks developers. Not for end users.\n   */\n  baseUrl?: string;\n};\n\nlet hasWarnedIfNoResolveUsers = false;\n\nfunction warnIfNoResolveUsers(usersCache?: AsyncCache<unknown, unknown>) {\n  if (\n    !hasWarnedIfNoResolveUsers &&\n    !usersCache &&\n    process.env.NODE_ENV !== \"production\"\n  ) {\n    console.warn(\n      \"Set the resolveUsers option in createRoomContext to specify user info.\"\n    );\n    hasWarnedIfNoResolveUsers = true;\n  }\n}\n\nconst ContextBundle = React.createContext<InternalRoomContextBundle<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  never,\n  BaseMetadata\n> | null>(null);\n\n/**\n * @private\n *\n * This is an internal API, use `createRoomContext` instead.\n */\nexport function useRoomContextBundle() {\n  const bundle = React.useContext(ContextBundle);\n  if (bundle === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return bundle;\n}\n\nexport function createRoomContext<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject = LsonObject,\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n  TRoomEvent extends Json = never,\n  TThreadMetadata extends BaseMetadata = never,\n>(\n  client: Client,\n  options?: Options<TUserMeta>\n): RoomContextBundle<\n  TPresence,\n  TStorage,\n  TUserMeta,\n  TRoomEvent,\n  TThreadMetadata\n> {\n  type TRoom = Room<TPresence, TStorage, TUserMeta, TRoomEvent>;\n  type TRoomLeavePair = { room: TRoom; leave: () => void };\n\n  const RoomContext = React.createContext<TRoom | null>(null);\n\n  const commentsErrorEventSource =\n    makeEventSource<CommentsError<TThreadMetadata>>();\n\n  const { CommentsRoomProvider, ...commentsRoom } =\n    createCommentsRoom<TThreadMetadata>(commentsErrorEventSource);\n\n  /**\n   * RATIONALE:\n   * At the \"Outer\" RoomProvider level, we keep a cache and produce\n   * a stableEnterRoom function, which we pass down to the real \"Inner\"\n   * RoomProvider level.\n   *\n   * The purpose is to ensure that if `stableEnterRoom(\"my-room\")` is called\n   * multiple times for the same room ID, it will always return the exact same\n   * (cached) value, so that in total only a single \"leave\" function gets\n   * produced and registered in the client.\n   *\n   * If we didn't use this cache, then in React StrictMode\n   * stableEnterRoom(\"my-room\") might get called multiple (at least 4) times,\n   * causing more leave functions to be produced in the client, some of which\n   * we cannot get a hold on (because StrictMode would discard those results by\n   * design). This would make it appear to the Client that the Room is still in\n   * use by some party that hasn't called `leave()` on it yet, thus causing the\n   * Room to not be freed and destroyed when the component unmounts later.\n   */\n  function RoomProviderOuter(props: RoomProviderProps<TPresence, TStorage>) {\n    const [cache] = React.useState<Map<string, TRoomLeavePair>>(\n      () => new Map()\n    );\n\n    // Produce a version of client.enterRoom() that when called for the same\n    // room ID multiple times, will not keep producing multiple leave\n    // functions, but instead return the cached one.\n    const stableEnterRoom = React.useCallback(\n      (\n        roomId: string,\n        options: EnterOptions<TPresence, TStorage>\n      ): TRoomLeavePair => {\n        const cached = cache.get(roomId);\n        if (cached) return cached;\n\n        const rv = client.enterRoom<TPresence, TStorage, TUserMeta, TRoomEvent>(\n          roomId,\n          options\n        );\n\n        // Wrap the leave function to also delete the cached value\n        const origLeave = rv.leave;\n        rv.leave = () => {\n          origLeave();\n          cache.delete(roomId);\n        };\n\n        cache.set(roomId, rv);\n        return rv;\n      },\n      [cache]\n    );\n\n    return <RoomProviderInner {...props} stableEnterRoom={stableEnterRoom} />;\n  }\n\n  function RoomProviderInner(\n    props: RoomProviderProps<TPresence, TStorage> & {\n      stableEnterRoom: (\n        roomId: string,\n        options: EnterOptions<TPresence, TStorage>\n      ) => TRoomLeavePair;\n    }\n  ) {\n    const { id: roomId, stableEnterRoom } = props;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!roomId) {\n        throw new Error(\n          \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n        );\n      }\n\n      if (typeof roomId !== \"string\") {\n        throw new Error(\"RoomProvider id property should be a string.\");\n      }\n\n      const majorReactVersion = parseInt(React.version) || 1;\n      const oldReactVersion = majorReactVersion < 18;\n      errorIf(\n        oldReactVersion && props.unstable_batchedUpdates === undefined,\n        missing_unstable_batchedUpdates(majorReactVersion, roomId)\n      );\n      deprecateIf(\n        !oldReactVersion && props.unstable_batchedUpdates !== undefined,\n        superfluous_unstable_batchedUpdates\n      );\n    }\n\n    // Note: We'll hold on to the initial value given here, and ignore any\n    // changes to this argument in subsequent renders\n    const frozenProps = useInitial({\n      initialPresence: props.initialPresence,\n      initialStorage: props.initialStorage,\n      unstable_batchedUpdates: props.unstable_batchedUpdates,\n      autoConnect:\n        props.autoConnect ??\n        props.shouldInitiallyConnect ??\n        typeof window !== \"undefined\",\n    });\n\n    const [{ room }, setRoomLeavePair] = React.useState(() =>\n      stableEnterRoom(roomId, {\n        ...frozenProps,\n        autoConnect: false, // Deliberately using false here on the first render, see below\n      })\n    );\n\n    React.useEffect(() => {\n      const pair = stableEnterRoom(roomId, frozenProps);\n\n      setRoomLeavePair(pair);\n      const { room, leave } = pair;\n\n      // In React, it's important to start connecting to the room as an effect,\n      // rather than doing this during the initial render. This means that\n      // during the initial render (both on the server-side, and on the first\n      // hydration on the client-side), the value of the `useStatus()` hook\n      // will correctly be \"initial\", and transition to \"connecting\" as an\n      // effect.\n      if (frozenProps.autoConnect) {\n        room.connect();\n      }\n\n      return () => {\n        leave();\n      };\n    }, [roomId, frozenProps, stableEnterRoom]);\n\n    return (\n      <RoomContext.Provider value={room}>\n        <CommentsRoomProvider room={room}>\n          <ContextBundle.Provider\n            value={\n              internalBundle as unknown as InternalRoomContextBundle<\n                JsonObject,\n                LsonObject,\n                BaseUserMeta,\n                never,\n                BaseMetadata\n              >\n            }\n          >\n            {props.children}\n          </ContextBundle.Provider>\n        </CommentsRoomProvider>\n      </RoomContext.Provider>\n    );\n  }\n\n  function connectionIdSelector(\n    others: readonly User<TPresence, TUserMeta>[]\n  ): number[] {\n    return others.map((user) => user.connectionId);\n  }\n\n  function useRoom(): TRoom {\n    const room = React.useContext(RoomContext);\n    if (room === null) {\n      throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return room;\n  }\n\n  function useStatus(): Status {\n    const room = useRoom();\n    const subscribe = room.events.status.subscribe;\n    const getSnapshot = room.getStatus;\n    const getServerSnapshot = room.getStatus;\n    return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  }\n\n  function useMyPresence(): [\n    TPresence,\n    (patch: Partial<TPresence>, options?: { addToHistory: boolean }) => void,\n  ] {\n    const room = useRoom();\n    const subscribe = room.events.myPresence.subscribe;\n    const getSnapshot = room.getPresence;\n    const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n    const setPresence = room.updatePresence;\n    return [presence, setPresence];\n  }\n\n  function useUpdateMyPresence(): (\n    patch: Partial<TPresence>,\n    options?: { addToHistory: boolean }\n  ) => void {\n    return useRoom().updatePresence;\n  }\n\n  function useOthers(): readonly User<TPresence, TUserMeta>[];\n  function useOthers<T>(\n    selector: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T;\n  function useOthers<T>(\n    selector?: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | readonly User<TPresence, TUserMeta>[] {\n    const room = useRoom();\n    const subscribe = room.events.others.subscribe;\n    const getSnapshot = room.getOthers;\n    const getServerSnapshot = alwaysEmptyList;\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector ??\n        (identity as (others: readonly User<TPresence, TUserMeta>[]) => T),\n      isEqual\n    );\n  }\n\n  function useOthersConnectionIds(): readonly number[] {\n    return useOthers(connectionIdSelector, shallow);\n  }\n\n  function useOthersMapped<T>(\n    itemSelector: (other: User<TPresence, TUserMeta>) => T,\n    itemIsEqual?: (prev: T, curr: T) => boolean\n  ): ReadonlyArray<readonly [connectionId: number, data: T]> {\n    const wrappedSelector = React.useCallback(\n      (others: readonly User<TPresence, TUserMeta>[]) =>\n        others.map(\n          (other) => [other.connectionId, itemSelector(other)] as const\n        ),\n      [itemSelector]\n    );\n\n    const wrappedIsEqual = React.useCallback(\n      (\n        a: ReadonlyArray<readonly [connectionId: number, data: T]>,\n        b: ReadonlyArray<readonly [connectionId: number, data: T]>\n      ): boolean => {\n        const eq = itemIsEqual ?? Object.is;\n        return (\n          a.length === b.length &&\n          a.every((atuple, index) => {\n            const btuple = b[index];\n            return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n          })\n        );\n      },\n      [itemIsEqual]\n    );\n\n    return useOthers(wrappedSelector, wrappedIsEqual);\n  }\n\n  const NOT_FOUND = Symbol();\n\n  type NotFound = typeof NOT_FOUND;\n\n  function useOther<T>(\n    connectionId: number,\n    selector: (other: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    const wrappedSelector = React.useCallback(\n      (others: readonly User<TPresence, TUserMeta>[]) => {\n        // TODO: Make this O(1) instead of O(n)?\n        const other = others.find(\n          (other) => other.connectionId === connectionId\n        );\n        return other !== undefined ? selector(other) : NOT_FOUND;\n      },\n      [connectionId, selector]\n    );\n\n    const wrappedIsEqual = React.useCallback(\n      (prev: T | NotFound, curr: T | NotFound): boolean => {\n        if (prev === NOT_FOUND || curr === NOT_FOUND) {\n          return prev === curr;\n        }\n\n        const eq = isEqual ?? Object.is;\n        return eq(prev, curr);\n      },\n      [isEqual]\n    );\n\n    const other = useOthers(wrappedSelector, wrappedIsEqual);\n    if (other === NOT_FOUND) {\n      throw new Error(\n        `No such other user with connection id ${connectionId} exists`\n      );\n    }\n\n    return other;\n  }\n\n  function useBroadcastEvent(): (\n    event: TRoomEvent,\n    options?: BroadcastOptions\n  ) => void {\n    const room = useRoom();\n\n    return React.useCallback(\n      (\n        event: TRoomEvent,\n        options: BroadcastOptions = { shouldQueueEventIfNotReady: false }\n      ) => {\n        room.broadcastEvent(event, options);\n      },\n      [room]\n    );\n  }\n\n  function useOthersListener(\n    callback: (event: OthersEvent<TPresence, TUserMeta>) => void\n  ) {\n    const room = useRoom();\n    const savedCallback = useLatest(callback);\n\n    React.useEffect(\n      () =>\n        room.events.others.subscribe((event) => savedCallback.current(event)),\n      [room, savedCallback]\n    );\n  }\n\n  function useLostConnectionListener(\n    callback: (event: LostConnectionEvent) => void\n  ): void {\n    const room = useRoom();\n    const savedCallback = useLatest(callback);\n\n    React.useEffect(\n      () =>\n        room.events.lostConnection.subscribe((event) =>\n          savedCallback.current(event)\n        ),\n      [room, savedCallback]\n    );\n  }\n\n  function useErrorListener(callback: (err: Error) => void): void {\n    const room = useRoom();\n    const savedCallback = useLatest(callback);\n\n    React.useEffect(\n      () => room.events.error.subscribe((e) => savedCallback.current(e)),\n      [room, savedCallback]\n    );\n  }\n\n  function useEventListener(\n    callback: (data: RoomEventMessage<TPresence, TUserMeta, TRoomEvent>) => void\n  ): void {\n    const room = useRoom();\n    const savedCallback = useLatest(callback);\n\n    React.useEffect(() => {\n      const listener = (\n        eventData: RoomEventMessage<TPresence, TUserMeta, TRoomEvent>\n      ) => {\n        savedCallback.current(eventData);\n      };\n\n      return room.events.customEvent.subscribe(listener);\n    }, [room, savedCallback]);\n  }\n\n  function useSelf(): User<TPresence, TUserMeta> | null;\n  function useSelf<T>(\n    selector: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | null;\n  function useSelf<T>(\n    maybeSelector?: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | User<TPresence, TUserMeta> | null {\n    type Snapshot = User<TPresence, TUserMeta> | null;\n    type Selection = T | null;\n\n    const room = useRoom();\n    const subscribe = room.events.self.subscribe;\n    const getSnapshot: () => Snapshot = room.getSelf;\n\n    const selector =\n      maybeSelector ?? (identity as (me: User<TPresence, TUserMeta>) => T);\n    const wrappedSelector = React.useCallback(\n      (me: Snapshot): Selection => (me !== null ? selector(me) : null),\n      [selector]\n    );\n\n    const getServerSnapshot = alwaysNull;\n\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      wrappedSelector,\n      isEqual\n    );\n  }\n\n  function useMutableStorageRoot(): LiveObject<TStorage> | null {\n    const room = useRoom();\n    const subscribe = room.events.storageDidLoad.subscribeOnce;\n    const getSnapshot = room.getStorageSnapshot;\n    const getServerSnapshot = alwaysNull;\n    return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  }\n\n  // NOTE: This API exists for backward compatible reasons\n  function useStorageRoot(): [root: LiveObject<TStorage> | null] {\n    return [useMutableStorageRoot()];\n  }\n\n  function useHistory(): History {\n    return useRoom().history;\n  }\n\n  function useUndo(): () => void {\n    return useHistory().undo;\n  }\n\n  function useRedo(): () => void {\n    return useHistory().redo;\n  }\n\n  function useCanUndo(): boolean {\n    const room = useRoom();\n    const subscribe = room.events.history.subscribe;\n    const canUndo = room.history.canUndo;\n    return useSyncExternalStore(subscribe, canUndo, canUndo);\n  }\n\n  function useCanRedo(): boolean {\n    const room = useRoom();\n    const subscribe = room.events.history.subscribe;\n    const canRedo = room.history.canRedo;\n    return useSyncExternalStore(subscribe, canRedo, canRedo);\n  }\n\n  function useBatch<T>(): (callback: () => T) => T {\n    return useRoom().batch;\n  }\n\n  function useLegacyKey<TKey extends Extract<keyof TStorage, string>>(\n    key: TKey\n  ): TStorage[TKey] | null {\n    const room = useRoom();\n    const rootOrNull = useMutableStorageRoot();\n    const rerender = useRerender();\n\n    React.useEffect(() => {\n      if (rootOrNull === null) {\n        return;\n      }\n      const root = rootOrNull;\n\n      let unsubCurr: (() => void) | undefined;\n      let curr = root.get(key);\n\n      function subscribeToCurr() {\n        unsubCurr = isLiveNode(curr)\n          ? room.subscribe(curr, rerender)\n          : undefined;\n      }\n\n      function onRootChange() {\n        const newValue = root.get(key);\n        if (newValue !== curr) {\n          unsubCurr?.();\n          curr = newValue;\n          subscribeToCurr();\n          rerender();\n        }\n      }\n\n      subscribeToCurr();\n      rerender();\n\n      const unsubscribeRoot = room.subscribe(root, onRootChange);\n      return () => {\n        unsubscribeRoot();\n        unsubCurr?.();\n      };\n    }, [rootOrNull, room, key, rerender]);\n\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      return rootOrNull.get(key);\n    }\n  }\n\n  function useStorage<T>(\n    selector: (root: ToImmutable<TStorage>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | null {\n    type Snapshot = ToImmutable<TStorage> | null;\n    type Selection = T | null;\n\n    const room = useRoom();\n    const rootOrNull = useMutableStorageRoot();\n\n    const wrappedSelector = React.useCallback(\n      (rootOrNull: Snapshot): Selection =>\n        rootOrNull !== null ? selector(rootOrNull) : null,\n      [selector]\n    );\n\n    const subscribe = React.useCallback(\n      (onStoreChange: () => void) =>\n        rootOrNull !== null\n          ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true })\n          : noop,\n      [room, rootOrNull]\n    );\n\n    const getSnapshot = React.useCallback((): Snapshot => {\n      if (rootOrNull === null) {\n        return null;\n      } else {\n        const root = rootOrNull;\n        const imm = root.toImmutable();\n        return imm;\n      }\n    }, [rootOrNull]);\n\n    const getServerSnapshot = alwaysNull;\n\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      wrappedSelector,\n      isEqual\n    );\n  }\n\n  function ensureNotServerSide(): void {\n    // Error early if suspense is used in a server-side context\n    if (typeof window === \"undefined\") {\n      throw new Error(\n        \"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\"\n      );\n    }\n  }\n\n  function useSuspendUntilStorageLoaded(): void {\n    const room = useRoom();\n    if (room.getStorageSnapshot() !== null) {\n      return;\n    }\n\n    ensureNotServerSide();\n\n    // Throw a _promise_. Suspense will suspend the component tree until this\n    // promise resolves (aka until storage has loaded). After that, it will\n    // render this component tree again.\n    throw new Promise<void>((res) => {\n      room.events.storageDidLoad.subscribeOnce(() => res());\n    });\n  }\n\n  function useSuspendUntilPresenceLoaded(): void {\n    const room = useRoom();\n    if (room.getSelf() !== null) {\n      return;\n    }\n\n    ensureNotServerSide();\n\n    // Throw a _promise_. Suspense will suspend the component tree until either\n    // until either a presence update event, or a connection status change has\n    // happened. After that, it will render this component tree again and\n    // re-evaluate the .getSelf() condition above, or re-suspend again until\n    // such event happens.\n    throw new Promise<void>((res) => {\n      room.events.self.subscribeOnce(() => res());\n      room.events.status.subscribeOnce(() => res());\n    });\n  }\n\n  function useMutation<\n    F extends (\n      context: MutationContext<TPresence, TStorage, TUserMeta>,\n      ...args: any[]\n    ) => any,\n  >(callback: F, deps: readonly unknown[]): OmitFirstArg<F> {\n    const room = useRoom();\n    return React.useMemo(\n      () => {\n        return ((...args) =>\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          room.batch(() =>\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n              ...args\n            )\n          )) as OmitFirstArg<F>;\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [room, ...deps]\n    );\n  }\n\n  function useStorageSuspense<T>(\n    selector: (root: ToImmutable<TStorage>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    useSuspendUntilStorageLoaded();\n    return useStorage(\n      selector,\n      isEqual as (prev: T | null, curr: T | null) => boolean\n    ) as T;\n  }\n\n  function useSelfSuspense(): User<TPresence, TUserMeta>;\n  function useSelfSuspense<T>(\n    selector: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T;\n  function useSelfSuspense<T>(\n    selector?: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | User<TPresence, TUserMeta> {\n    useSuspendUntilPresenceLoaded();\n    return useSelf(\n      selector as (me: User<TPresence, TUserMeta>) => T,\n      isEqual as (prev: T | null, curr: T | null) => boolean\n    ) as T | User<TPresence, TUserMeta>;\n  }\n\n  function useOthersSuspense<T>(\n    selector?: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | readonly User<TPresence, TUserMeta>[] {\n    useSuspendUntilPresenceLoaded();\n    return useOthers(\n      selector as (others: readonly User<TPresence, TUserMeta>[]) => T,\n      isEqual as (prev: T, curr: T) => boolean\n    ) as T | readonly User<TPresence, TUserMeta>[];\n  }\n\n  function useOthersConnectionIdsSuspense(): readonly number[] {\n    useSuspendUntilPresenceLoaded();\n    return useOthersConnectionIds();\n  }\n\n  function useOthersMappedSuspense<T>(\n    itemSelector: (other: User<TPresence, TUserMeta>) => T,\n    itemIsEqual?: (prev: T, curr: T) => boolean\n  ): ReadonlyArray<readonly [connectionId: number, data: T]> {\n    useSuspendUntilPresenceLoaded();\n    return useOthersMapped(itemSelector, itemIsEqual);\n  }\n\n  function useOtherSuspense<T>(\n    connectionId: number,\n    selector: (other: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    useSuspendUntilPresenceLoaded();\n    return useOther(connectionId, selector, isEqual);\n  }\n\n  function useLegacyKeySuspense<TKey extends Extract<keyof TStorage, string>>(\n    key: TKey\n  ): TStorage[TKey] {\n    useSuspendUntilStorageLoaded();\n    return useLegacyKey(key) as TStorage[TKey];\n  }\n\n  function useThreads(\n    options?: GetThreadsOptions<TThreadMetadata>\n  ): ThreadsState<TThreadMetadata> {\n    const room = useRoom();\n    return commentsRoom.useThreads(room, options);\n  }\n\n  function useThreadsSuspense(options?: GetThreadsOptions<TThreadMetadata>) {\n    const room = useRoom();\n    return commentsRoom.useThreadsSuspense(room, options);\n  }\n\n  function useCreateThread() {\n    const room = useRoom();\n    return commentsRoom.useCreateThread(room);\n  }\n\n  function useEditThreadMetadata() {\n    const room = useRoom();\n    return commentsRoom.useEditThreadMetadata(room);\n  }\n\n  function useAddReaction() {\n    const room = useRoom();\n    return commentsRoom.useAddReaction(room);\n  }\n\n  function useRemoveReaction() {\n    const room = useRoom();\n    return commentsRoom.useRemoveReaction(room);\n  }\n\n  function useCreateComment(): (options: CreateCommentOptions) => CommentData {\n    const room = useRoom();\n    return commentsRoom.useCreateComment(room);\n  }\n\n  function useEditComment(): (options: EditCommentOptions) => void {\n    const room = useRoom();\n    return commentsRoom.useEditComment(room);\n  }\n\n  function useDeleteComment() {\n    const room = useRoom();\n    return commentsRoom.useDeleteComment(room);\n  }\n\n  const { resolveUsers, resolveMentionSuggestions } = options ?? {};\n\n  const usersCache = resolveUsers\n    ? createAsyncCache(async (stringifiedOptions: string) => {\n        const users = await resolveUsers(\n          JSON.parse(stringifiedOptions) as ResolveUsersArgs\n        );\n\n        return users?.[0];\n      })\n    : undefined;\n\n  function useUser(userId: string) {\n    const room = useRoom();\n    const resolverKey = React.useMemo(\n      () => stringify({ userIds: [userId], roomId: room.id }),\n      [userId, room.id]\n    );\n    const state = useAsyncCache(usersCache, resolverKey);\n\n    React.useEffect(() => warnIfNoResolveUsers(usersCache), []);\n\n    if (state.isLoading) {\n      return {\n        isLoading: true,\n      } as UserState<TUserMeta[\"info\"]>;\n    } else {\n      return {\n        user: state.data,\n        error: state.error,\n        isLoading: false,\n      } as UserState<TUserMeta[\"info\"]>;\n    }\n  }\n\n  function useUserSuspense(userId: string) {\n    const room = useRoom();\n    const resolverKey = React.useMemo(\n      () => stringify({ userIds: [userId], roomId: room.id }),\n      [userId, room.id]\n    );\n    const state = useAsyncCache(usersCache, resolverKey, {\n      suspense: true,\n    });\n\n    React.useEffect(() => warnIfNoResolveUsers(usersCache), []);\n\n    return {\n      user: state.data,\n      isLoading: false,\n    } as UserStateSuccess<TUserMeta[\"info\"]>;\n  }\n\n  const mentionSuggestionsCache = createAsyncCache<string[], unknown>(\n    resolveMentionSuggestions\n      ? (stringifiedOptions: string) => {\n          return resolveMentionSuggestions(\n            JSON.parse(stringifiedOptions) as ResolveMentionSuggestionsArgs\n          );\n        }\n      : () => Promise.resolve([])\n  );\n\n  function useMentionSuggestions(search?: string) {\n    const room = useRoom();\n    const debouncedSearch = useDebounce(search, 500);\n    const resolverKey = React.useMemo(\n      () =>\n        debouncedSearch !== undefined\n          ? stringify({ text: debouncedSearch, roomId: room.id })\n          : null,\n      [debouncedSearch, room.id]\n    );\n    const { data } = useAsyncCache(mentionSuggestionsCache, resolverKey, {\n      keepPreviousDataWhileLoading: true,\n    });\n\n    return data;\n  }\n\n  const bundle: RoomContextBundle<\n    TPresence,\n    TStorage,\n    TUserMeta,\n    TRoomEvent,\n    TThreadMetadata\n  > = {\n    RoomContext,\n    RoomProvider: RoomProviderOuter,\n\n    useRoom,\n    useStatus,\n\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useErrorListener,\n    useEventListener,\n\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n\n    // These are just aliases. The passed-in key will define their return values.\n    useList: useLegacyKey,\n    useMap: useLegacyKey,\n    useObject: useLegacyKey,\n\n    useStorageRoot,\n    useStorage,\n\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n\n    useMutation,\n\n    useThreads,\n    useUser,\n\n    useCreateThread,\n    useEditThreadMetadata,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProviderOuter,\n\n      useRoom,\n      useStatus,\n\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useErrorListener,\n      useEventListener,\n\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n\n      // Legacy hooks\n      useList: useLegacyKeySuspense,\n      useMap: useLegacyKeySuspense,\n      useObject: useLegacyKeySuspense,\n\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n\n      useMutation,\n\n      useThreads: useThreadsSuspense,\n      useUser: useUserSuspense,\n\n      useCreateThread,\n      useEditThreadMetadata,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n    },\n  };\n\n  const internalBundle: InternalRoomContextBundle<\n    TPresence,\n    TStorage,\n    TUserMeta,\n    TRoomEvent,\n    TThreadMetadata\n  > = {\n    ...bundle,\n    hasResolveMentionSuggestions: resolveMentionSuggestions !== undefined,\n    useMentionSuggestions,\n  };\n\n  return bundle;\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  CommentBody,\n  CommentData,\n  CommentReaction,\n  EventSource,\n  GetThreadsOptions,\n  Json,\n  JsonObject,\n  LsonObject,\n  Resolve,\n  Room,\n  ThreadData,\n} from \"@liveblocks/core\";\nimport { CommentsApiError, makeEventSource, stringify } from \"@liveblocks/core\";\nimport { nanoid } from \"nanoid\";\nimport type { PropsWithChildren } from \"react\";\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n} from \"react\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\n\nimport { useSyncExternalStore } from \"../factory\";\nimport {\n  AddReactionError,\n  type CommentsError,\n  CreateCommentError,\n  CreateThreadError,\n  DeleteCommentError,\n  EditCommentError,\n  EditThreadMetadataError,\n  RemoveReactionError,\n} from \"./errors\";\nimport type {\n  CacheManager,\n  MutationInfo,\n  RequestInfo,\n} from \"./lib/revalidation\";\nimport { useMutate, useRevalidateCache } from \"./lib/revalidation\";\nimport useIsDocumentVisible from \"./lib/use-is-document-visible\";\nimport useIsOnline from \"./lib/use-is-online\";\n\nconst THREAD_ID_PREFIX = \"th\";\nconst COMMENT_ID_PREFIX = \"cm\";\n\nexport const POLLING_INTERVAL_REALTIME = 30000;\nexport const POLLING_INTERVAL = 5000;\n\ntype PartialNullable<T> = {\n  [P in keyof T]?: T[P] | null | undefined;\n};\n\nexport type UseThreadsOptions<TThreadMetadata extends BaseMetadata> =\n  GetThreadsOptions<TThreadMetadata>;\n\nexport type CommentsRoom<TThreadMetadata extends BaseMetadata> = {\n  CommentsRoomProvider({\n    room,\n    children,\n  }: PropsWithChildren<{\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>;\n  }>): JSX.Element;\n  useThreads(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n    options?: GetThreadsOptions<TThreadMetadata>\n  ): ThreadsState<TThreadMetadata>;\n  useThreadsSuspense(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n    options?: GetThreadsOptions<TThreadMetadata>\n  ): ThreadsStateSuccess<TThreadMetadata>;\n  useCreateThread(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ): (\n    options: CreateThreadOptions<TThreadMetadata>\n  ) => ThreadData<TThreadMetadata>;\n  useEditThreadMetadata(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ): (options: EditThreadMetadataOptions<TThreadMetadata>) => void;\n  useCreateComment(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ): (options: CreateCommentOptions) => CommentData;\n  useEditComment(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ): (options: EditCommentOptions) => void;\n  useDeleteComment(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ): (options: DeleteCommentOptions) => void;\n  useAddReaction(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ): (options: CommentReactionOptions) => void;\n  useRemoveReaction(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ): (options: CommentReactionOptions) => void;\n};\n\nexport type CreateThreadOptions<TMetadata extends BaseMetadata> = [\n  TMetadata,\n] extends [never]\n  ? {\n      body: CommentBody;\n    }\n  : { body: CommentBody; metadata: TMetadata };\n\nexport type EditThreadMetadataOptions<TMetadata extends BaseMetadata> = [\n  TMetadata,\n] extends [never]\n  ? {\n      threadId: string;\n    }\n  : { threadId: string; metadata: Resolve<PartialNullable<TMetadata>> };\n\nexport type CreateCommentOptions = {\n  threadId: string;\n  body: CommentBody;\n};\n\nexport type EditCommentOptions = {\n  threadId: string;\n  commentId: string;\n  body: CommentBody;\n};\n\nexport type DeleteCommentOptions = {\n  threadId: string;\n  commentId: string;\n};\n\nexport type CommentReactionOptions = {\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\nexport type ThreadsStateLoading = {\n  isLoading: true;\n  threads?: never;\n  error?: never;\n};\n\nexport type ThreadsStateResolved<TThreadMetadata extends BaseMetadata> = {\n  isLoading: false;\n  threads: ThreadData<TThreadMetadata>[];\n  error?: Error;\n};\n\nexport type ThreadsStateSuccess<TThreadMetadata extends BaseMetadata> = {\n  isLoading: false;\n  threads: ThreadData<TThreadMetadata>[];\n  error?: never;\n};\n\nexport type ThreadsState<TThreadMetadata extends BaseMetadata> =\n  | ThreadsStateLoading\n  | ThreadsStateResolved<TThreadMetadata>;\n\nexport function createCommentsRoom<TThreadMetadata extends BaseMetadata>(\n  errorEventSource: EventSource<CommentsError<TThreadMetadata>>\n) {\n  const store = createClientCacheStore<TThreadMetadata>();\n\n  const FetcherContext = createContext<\n    (() => Promise<ThreadData<TThreadMetadata>[]>) | null\n  >(null);\n\n  const RoomManagerContext = createContext<ReturnType<\n    typeof createRoomRevalidationManager<TThreadMetadata>\n  > | null>(null);\n\n  function getThreads<TThreadMetadata extends BaseMetadata>(\n    manager: ReturnType<typeof createRoomRevalidationManager<TThreadMetadata>>\n  ): ThreadData<TThreadMetadata>[] {\n    const threads = manager.getCache();\n    if (!threads) {\n      throw new Error(\n        \"Cannot update threads or comments before they are loaded.\"\n      );\n    }\n    return threads;\n  }\n\n  function CommentsRoomProvider({\n    room,\n    children,\n  }: PropsWithChildren<{\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>;\n  }>) {\n    const manager = useMemo(() => {\n      return createRoomRevalidationManager(room.id, {\n        getCache: store.getThreads,\n        setCache: store.setThreads,\n      });\n    }, [room.id]);\n\n    const fetcher = React.useCallback(async () => {\n      const options = manager\n        .getRevalidationManagers()\n        .filter(([key]) => manager.getReferenceCount(key) > 0)\n        .map(([_, manager]) => manager.getOptions());\n\n      const responses = await Promise.all(\n        options.map(async (option) => {\n          return await room.getThreads(option);\n        })\n      );\n\n      const threads = Array.from(\n        new Map(responses.flat().map((thread) => [thread.id, thread])).values()\n      );\n\n      return threads;\n    }, [room, manager]);\n\n    const revalidateCache = useRevalidateCache(manager, fetcher);\n\n    const status = useSyncExternalStore(\n      room.events.status.subscribe,\n      room.getStatus,\n      room.getStatus\n    );\n\n    const isOnline = useIsOnline();\n    const isDocumentVisible = useIsDocumentVisible();\n\n    const refreshInterval = getPollingInterval(\n      isOnline,\n      isDocumentVisible,\n      status === \"connected\"\n    );\n\n    /**\n     * Periodically revalidate the cache. The revalidation is skipped if the browser is offline or if the document is not visible.\n     */\n    useEffect(() => {\n      let revalidationTimerId: number;\n\n      function scheduleRevalidation() {\n        if (refreshInterval === 0) return;\n\n        revalidationTimerId = window.setTimeout(() => {\n          // Only revalidate if the browser is online AND document is visible AND there are currently no errors AND there is at least one `useThreads` hook that is using the cache, otherwise schedule the next revalidation\n          if (\n            isOnline &&\n            isDocumentVisible &&\n            !manager.getError() &&\n            manager.getTotalReferenceCount() > 0\n          ) {\n            // Revalidate cache and then schedule the next revalidation\n            void revalidateCache({ shouldDedupe: true }).then(\n              scheduleRevalidation\n            );\n            return;\n          }\n\n          scheduleRevalidation();\n        }, refreshInterval);\n      }\n\n      // Schedule the first revalidation\n      scheduleRevalidation();\n\n      return () => {\n        window.clearTimeout(revalidationTimerId);\n      };\n    }, [\n      revalidateCache,\n      refreshInterval,\n      isOnline,\n      isDocumentVisible,\n      manager,\n    ]);\n\n    /**\n     * Subscribe to the 'online' event to trigger a revalidation when the browser comes back online.\n     * Note: There is a 'navigator.onLine' property that can be used to determine the online status of the browser, but it is not reliable (see https://bugs.chromium.org/p/chromium/issues/detail?id=678075).\n     */\n    useEffect(() => {\n      function handleIsOnline() {\n        if (isDocumentVisible) {\n          void revalidateCache({ shouldDedupe: true });\n        }\n      }\n\n      window.addEventListener(\"online\", handleIsOnline);\n      return () => {\n        window.removeEventListener(\"online\", handleIsOnline);\n      };\n    }, [revalidateCache, isDocumentVisible]);\n\n    /**\n     * Subscribe to visibility change events to trigger a revalidation when the document becomes visible.\n     */\n    useEffect(() => {\n      function handleVisibilityChange() {\n        const isVisible = document.visibilityState === \"visible\";\n        if (isVisible && isOnline) {\n          void revalidateCache({ shouldDedupe: true });\n        }\n      }\n\n      document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n      return () => {\n        document.removeEventListener(\n          \"visibilitychange\",\n          handleVisibilityChange\n        );\n      };\n    }, [revalidateCache, isOnline]);\n\n    useEffect(() => {\n      const unsubscribe = room.events.comments.subscribe(() => {\n        void revalidateCache({ shouldDedupe: false });\n      });\n      return () => {\n        unsubscribe();\n      };\n    }, [room, revalidateCache]);\n\n    return (\n      <FetcherContext.Provider value={fetcher}>\n        <RoomManagerContext.Provider value={manager}>\n          {children}\n        </RoomManagerContext.Provider>\n      </FetcherContext.Provider>\n    );\n  }\n\n  function useRoomManager() {\n    const manager = useContext(RoomManagerContext);\n    if (manager === null) {\n      throw new Error(\"CommentsRoomProvider is missing from the React tree.\");\n    }\n    return manager;\n  }\n\n  /**\n   * Creates a new revalidation manager for the given filter options and room manager. If a revalidation manager already exists for the given filter options, it will be returned instead.\n   */\n  function getUseThreadsRevalidationManager<\n    TThreadMetadata extends BaseMetadata,\n  >(\n    options: GetThreadsOptions<TThreadMetadata>,\n    roomManager: ReturnType<\n      typeof createRoomRevalidationManager<TThreadMetadata>\n    >\n  ) {\n    const key = stringify(options);\n    const revalidationManager = roomManager.getRevalidationManager(key);\n\n    if (!revalidationManager) {\n      const useThreadsRevalidationManager =\n        createUseThreadsRevalidationManager<TThreadMetadata>(\n          options,\n          roomManager\n        );\n      roomManager.setRevalidationmanager(key, useThreadsRevalidationManager);\n      return useThreadsRevalidationManager;\n    }\n\n    return revalidationManager;\n  }\n\n  /**\n   * @internal\n   */\n  function useThreadsFetcher() {\n    const fetcher = useContext(FetcherContext);\n    if (fetcher === null) {\n      throw new Error(\"CommentsRoomProvider is missing from the React tree.\");\n    }\n    return fetcher;\n  }\n\n  function useThreads(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n    options: UseThreadsOptions<TThreadMetadata> = { query: { metadata: {} } }\n  ): ThreadsState<TThreadMetadata> {\n    const key = useMemo(() => stringify(options), [options]);\n    const manager = useRoomManager();\n\n    const useThreadsRevalidationManager = getUseThreadsRevalidationManager(\n      options,\n      manager\n    );\n\n    const fetcher = React.useCallback(\n      () => {\n        return room.getThreads(options);\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render\n      [key, room]\n    );\n\n    const revalidateCache = useRevalidateCache(\n      useThreadsRevalidationManager,\n      fetcher\n    );\n\n    useEffect(() => {\n      void revalidateCache({ shouldDedupe: true });\n    }, [revalidateCache]);\n\n    useEffect(() => {\n      manager.incrementReferenceCount(key);\n      return () => {\n        manager.decrementReferenceCount(key);\n      };\n    }, [manager, key]);\n\n    const cache = _useThreads(room, options);\n\n    return cache;\n  }\n\n  function useThreadsSuspense(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n    options: UseThreadsOptions<TThreadMetadata> = { query: { metadata: {} } }\n  ): ThreadsStateSuccess<TThreadMetadata> {\n    const key = useMemo(() => stringify(options), [options]);\n    const manager = useRoomManager();\n\n    const useThreadsRevalidationManager = getUseThreadsRevalidationManager(\n      options,\n      manager\n    );\n\n    const fetcher = React.useCallback(\n      () => {\n        return room.getThreads(options);\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- The missing dependency is `options` but `key` and `normalized` are analogous, so we only include `key` as dependency. This helps minimize the number of re-renders as `options` can change on each render\n      [key, room]\n    );\n\n    const revalidateCache = useRevalidateCache(\n      useThreadsRevalidationManager,\n      fetcher\n    );\n\n    useEffect(() => {\n      void revalidateCache({ shouldDedupe: true });\n    }, [revalidateCache]);\n\n    useEffect(() => {\n      manager.incrementReferenceCount(key);\n      return () => {\n        manager.decrementReferenceCount(key);\n      };\n    }, [manager, key]);\n\n    const cache = _useThreads(room, options);\n\n    if (cache.error) {\n      throw cache.error;\n    }\n\n    if (cache.isLoading || !cache.threads) {\n      throw revalidateCache({\n        shouldDedupe: true,\n      });\n    }\n\n    return {\n      isLoading: false,\n      threads: cache.threads,\n      error: cache.error,\n    };\n  }\n\n  function _useThreads(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n    options: UseThreadsOptions<TThreadMetadata>\n  ): ThreadsState<TThreadMetadata> {\n    const manager = useRoomManager();\n    const useThreadsRevalidationManager = getUseThreadsRevalidationManager(\n      options,\n      manager\n    );\n\n    return useSyncExternalStoreWithSelector(\n      store.subscribe,\n      () => store.getThreads(),\n      () => store.getThreads(),\n      (state) => {\n        const isLoading = useThreadsRevalidationManager.getIsLoading();\n        if (isLoading) {\n          return {\n            isLoading: true,\n          };\n        }\n\n        const options = useThreadsRevalidationManager.getOptions();\n        const error = useThreadsRevalidationManager.getError();\n\n        // Filter the cache to only include threads that match the current query\n        const filtered = state.filter((thread) => {\n          if (thread.roomId !== room.id) return false;\n\n          const query = options.query ?? {};\n          for (const key in query.metadata) {\n            if (thread.metadata[key] !== query.metadata[key]) {\n              return false;\n            }\n          }\n          return true;\n        });\n\n        return {\n          isLoading: false,\n          threads: filtered,\n          error,\n        };\n      }\n    );\n  }\n\n  function useEditThreadMetadata(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ) {\n    const manager = useRoomManager();\n\n    const fetcher = useThreadsFetcher();\n    const revalidate = useRevalidateCache(manager, fetcher);\n    const mutate = useMutate(manager, revalidate);\n\n    const editThreadMetadata = useCallback(\n      (options: EditThreadMetadataOptions<TThreadMetadata>): void => {\n        const threadId = options.threadId;\n        const metadata: PartialNullable<TThreadMetadata> =\n          \"metadata\" in options ? options.metadata : {};\n        const threads = getThreads(manager);\n\n        const optimisticData = threads.map((thread) =>\n          thread.id === threadId\n            ? {\n                ...thread,\n                metadata: {\n                  ...thread.metadata,\n                  ...metadata,\n                },\n              }\n            : thread\n        );\n\n        mutate(room.editThreadMetadata({ metadata, threadId }), {\n          optimisticData,\n        }).catch((err: unknown) => {\n          if (!(err instanceof CommentsApiError)) {\n            throw err;\n          }\n\n          const error = handleCommentsApiError(err);\n          errorEventSource.notify(\n            new EditThreadMetadataError(error, {\n              roomId: room.id,\n              threadId,\n              metadata,\n            })\n          );\n        });\n      },\n      [room, mutate, manager]\n    );\n\n    return editThreadMetadata;\n  }\n\n  function useCreateThread(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ) {\n    const manager = useRoomManager();\n\n    const fetcher = useThreadsFetcher();\n    const revalidate = useRevalidateCache(manager, fetcher);\n    const mutate = useMutate(manager, revalidate);\n\n    const createThread = useCallback(\n      (\n        options: CreateThreadOptions<TThreadMetadata>\n      ): ThreadData<TThreadMetadata> => {\n        const body = options.body;\n        const metadata: TThreadMetadata =\n          \"metadata\" in options ? options.metadata : ({} as TThreadMetadata);\n        const threads = getThreads(manager);\n\n        const threadId = createThreadId();\n        const commentId = createCommentId();\n        const now = new Date();\n\n        const newComment: CommentData = {\n          id: commentId,\n          threadId,\n          roomId: room.id,\n          createdAt: now,\n          type: \"comment\",\n          userId: getCurrentUserId(room),\n          body,\n          reactions: [],\n        };\n        const newThread = {\n          id: threadId,\n          type: \"thread\",\n          createdAt: now,\n          roomId: room.id,\n          metadata,\n          comments: [newComment],\n        } as ThreadData<TThreadMetadata>;\n\n        mutate(room.createThread({ threadId, commentId, body, metadata }), {\n          optimisticData: [...threads, newThread],\n        }).catch((err: unknown) => {\n          if (!(err instanceof CommentsApiError)) {\n            throw err;\n          }\n\n          const error = handleCommentsApiError(err);\n          errorEventSource.notify(\n            new CreateThreadError(error, {\n              roomId: room.id,\n              threadId,\n              commentId,\n              body,\n              metadata,\n            })\n          );\n        });\n\n        return newThread;\n      },\n      [room, mutate, manager]\n    );\n\n    return createThread;\n  }\n\n  function useCreateComment(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ): (options: CreateCommentOptions) => CommentData {\n    const manager = useRoomManager();\n\n    const fetcher = useThreadsFetcher();\n    const revalidate = useRevalidateCache(manager, fetcher);\n    const mutate = useMutate(manager, revalidate);\n\n    const createComment = useCallback(\n      ({ threadId, body }: CreateCommentOptions): CommentData => {\n        const threads = getThreads(manager);\n\n        const commentId = createCommentId();\n        const now = new Date();\n\n        const comment: CommentData = {\n          id: commentId,\n          threadId,\n          roomId: room.id,\n          type: \"comment\",\n          createdAt: now,\n          userId: getCurrentUserId(room),\n          body,\n          reactions: [],\n        };\n\n        const optimisticData = threads.map((thread) =>\n          thread.id === threadId\n            ? {\n                ...thread,\n                comments: [...thread.comments, comment],\n              }\n            : thread\n        );\n\n        mutate(room.createComment({ threadId, commentId, body }), {\n          optimisticData,\n        }).catch((err: unknown) => {\n          if (!(err instanceof CommentsApiError)) {\n            throw err;\n          }\n\n          const error = handleCommentsApiError(err);\n          errorEventSource.notify(\n            new CreateCommentError(error, {\n              roomId: room.id,\n              threadId,\n              commentId,\n              body,\n            })\n          );\n        });\n        return comment;\n      },\n      [room, mutate, manager]\n    );\n\n    return createComment;\n  }\n\n  function useEditComment(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ) {\n    const manager = useRoomManager();\n\n    const fetcher = useThreadsFetcher();\n    const revalidate = useRevalidateCache(manager, fetcher);\n    const mutate = useMutate(manager, revalidate);\n\n    const editComment = useCallback(\n      ({ threadId, commentId, body }: EditCommentOptions): void => {\n        const threads = getThreads(manager);\n        const now = new Date();\n\n        const optimisticData = threads.map((thread) =>\n          thread.id === threadId\n            ? {\n                ...thread,\n                comments: thread.comments.map((comment) =>\n                  comment.id === commentId\n                    ? ({\n                        ...comment,\n                        editedAt: now,\n                        body,\n                      } as CommentData)\n                    : comment\n                ),\n              }\n            : thread\n        );\n\n        mutate(room.editComment({ threadId, commentId, body }), {\n          optimisticData,\n        }).catch((err: unknown) => {\n          if (!(err instanceof CommentsApiError)) {\n            throw err;\n          }\n\n          const error = handleCommentsApiError(err);\n          errorEventSource.notify(\n            new EditCommentError(error, {\n              roomId: room.id,\n              threadId,\n              commentId,\n              body,\n            })\n          );\n        });\n      },\n      [room, mutate, manager]\n    );\n\n    return editComment;\n  }\n\n  function useDeleteComment(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ) {\n    const manager = useRoomManager();\n\n    const fetcher = useThreadsFetcher();\n    const revalidate = useRevalidateCache(manager, fetcher);\n    const mutate = useMutate(manager, revalidate);\n\n    const deleteComment = useCallback(\n      ({ threadId, commentId }: DeleteCommentOptions): void => {\n        const threads = getThreads(manager);\n        const now = new Date();\n\n        const newThreads: ThreadData<TThreadMetadata>[] = [];\n\n        for (const thread of threads) {\n          if (thread.id === threadId) {\n            const newThread: ThreadData<TThreadMetadata> = {\n              ...thread,\n              comments: thread.comments.map((comment) =>\n                comment.id === commentId\n                  ? {\n                      ...comment,\n                      deletedAt: now,\n                      body: undefined,\n                    }\n                  : comment\n              ),\n            };\n\n            if (\n              newThread.comments.some(\n                (comment) => comment.deletedAt === undefined\n              )\n            ) {\n              newThreads.push(newThread);\n            }\n          } else {\n            newThreads.push(thread);\n          }\n        }\n\n        mutate(room.deleteComment({ threadId, commentId }), {\n          optimisticData: newThreads,\n        }).catch((err: unknown) => {\n          if (!(err instanceof CommentsApiError)) {\n            throw err;\n          }\n\n          const error = handleCommentsApiError(err);\n          errorEventSource.notify(\n            new DeleteCommentError(error, {\n              roomId: room.id,\n              threadId,\n              commentId,\n            })\n          );\n        });\n      },\n      [room, mutate, manager]\n    );\n\n    return deleteComment;\n  }\n\n  function useAddReaction(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ) {\n    const manager = useRoomManager();\n\n    const fetcher = useThreadsFetcher();\n    const revalidate = useRevalidateCache(manager, fetcher);\n    const mutate = useMutate(manager, revalidate);\n\n    const createComment = useCallback(\n      ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n        const threads = getThreads(manager);\n        const now = new Date();\n        const userId = getCurrentUserId(room);\n\n        const optimisticData = threads.map((thread) =>\n          thread.id === threadId\n            ? {\n                ...thread,\n                comments: thread.comments.map((comment) => {\n                  if (comment.id !== commentId) {\n                    return comment;\n                  }\n\n                  let reactions: CommentReaction[];\n\n                  if (\n                    comment.reactions.some(\n                      (reaction) => reaction.emoji === emoji\n                    )\n                  ) {\n                    reactions = comment.reactions.map((reaction) =>\n                      reaction.emoji === emoji\n                        ? {\n                            ...reaction,\n                            users: [...reaction.users, { id: userId }],\n                          }\n                        : reaction\n                    );\n                  } else {\n                    reactions = [\n                      ...comment.reactions,\n                      {\n                        emoji,\n                        createdAt: now,\n                        users: [{ id: userId }],\n                      },\n                    ];\n                  }\n\n                  return {\n                    ...comment,\n                    reactions,\n                  };\n                }),\n              }\n            : thread\n        );\n\n        mutate(room.addReaction({ threadId, commentId, emoji }), {\n          optimisticData,\n        }).catch((err: unknown) => {\n          if (!(err instanceof CommentsApiError)) {\n            throw err;\n          }\n\n          const error = handleCommentsApiError(err);\n          errorEventSource.notify(\n            new AddReactionError(error, {\n              roomId: room.id,\n              threadId,\n              commentId,\n              emoji,\n            })\n          );\n        });\n      },\n      [room, mutate, manager]\n    );\n\n    return createComment;\n  }\n\n  function useRemoveReaction(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n  ) {\n    const manager = useRoomManager();\n\n    const fetcher = useThreadsFetcher();\n    const revalidate = useRevalidateCache(manager, fetcher);\n    const mutate = useMutate(manager, revalidate);\n\n    const createComment = useCallback(\n      ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n        const threads = getThreads(manager);\n        const userId = getCurrentUserId(room);\n\n        const optimisticData = threads.map((thread) =>\n          thread.id === threadId\n            ? {\n                ...thread,\n                comments: thread.comments.map((comment) => {\n                  if (comment.id !== commentId) {\n                    return comment;\n                  }\n\n                  const reactionIndex = comment.reactions.findIndex(\n                    (reaction) => reaction.emoji === emoji\n                  );\n                  let reactions: CommentReaction[] = comment.reactions;\n\n                  if (\n                    reactionIndex >= 0 &&\n                    comment.reactions[reactionIndex].users.some(\n                      (user) => user.id === userId\n                    )\n                  ) {\n                    if (comment.reactions[reactionIndex].users.length <= 1) {\n                      reactions = [...comment.reactions];\n                      reactions.splice(reactionIndex, 1);\n                    } else {\n                      reactions[reactionIndex] = {\n                        ...reactions[reactionIndex],\n                        users: reactions[reactionIndex].users.filter(\n                          (user) => user.id !== userId\n                        ),\n                      };\n                    }\n                  }\n\n                  return {\n                    ...comment,\n                    reactions,\n                  };\n                }),\n              }\n            : thread\n        );\n\n        mutate(room.removeReaction({ threadId, commentId, emoji }), {\n          optimisticData,\n        }).catch((err: unknown) => {\n          if (!(err instanceof CommentsApiError)) {\n            throw err;\n          }\n\n          const error = handleCommentsApiError(err);\n          errorEventSource.notify(\n            new RemoveReactionError(error, {\n              roomId: room.id,\n              threadId,\n              commentId,\n              emoji,\n            })\n          );\n        });\n      },\n      [room, mutate, manager]\n    );\n\n    return createComment;\n  }\n\n  return {\n    CommentsRoomProvider,\n    useThreads,\n    useThreadsSuspense,\n    useEditThreadMetadata,\n    useCreateThread,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n  };\n}\n\nfunction createOptimisticId(prefix: string) {\n  return `${prefix}_${nanoid()}`;\n}\n\nexport function createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\n\nexport function createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\n\nfunction getCurrentUserId(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n): string {\n  const self = room.getSelf();\n  if (self === null || self.id === undefined) {\n    return \"anonymous\";\n  } else {\n    return self.id;\n  }\n}\n\nfunction handleCommentsApiError(err: CommentsApiError): Error {\n  const message = `Request failed with status ${err.status}: ${err.message}`;\n\n  // Log details about FORBIDDEN errors\n  if (err.details?.error === \"FORBIDDEN\") {\n    const detailedMessage = [message, err.details.suggestion, err.details.docs]\n      .filter(Boolean)\n      .join(\"\\n\");\n\n    console.error(detailedMessage);\n  }\n\n  return new Error(message);\n}\n\ninterface ThreadsCacheManager<TThreadMetadata extends BaseMetadata>\n  extends CacheManager<ThreadData<TThreadMetadata>[]> {\n  subscribe(\n    type: \"cache\",\n    callback: (state: ThreadData<TThreadMetadata>[]) => void\n  ): () => void;\n  subscribe(type: \"error\", callback: (error: Error) => void): () => void;\n}\n\ninterface UseThreadsRevalidationManager<TThreadMetadata extends BaseMetadata>\n  extends CacheManager<ThreadData<TThreadMetadata>[]> {\n  getOptions(): GetThreadsOptions<TThreadMetadata>;\n  getIsLoading(): boolean;\n  setIsLoading(value: boolean): void;\n}\n\nexport function createRoomRevalidationManager<\n  TThreadMetadata extends BaseMetadata,\n>(\n  roomId: string,\n  {\n    getCache,\n    setCache,\n  }: {\n    getCache: () => ThreadData<TThreadMetadata>[];\n    setCache: (value: ThreadData<TThreadMetadata>[]) => void;\n  }\n) {\n  let request: RequestInfo<ThreadData<TThreadMetadata>[]> | undefined; // Stores the currently active revalidation request\n  let error: Error | undefined; // Stores any error that occurred during the last revalidation request\n  let mutation: MutationInfo | undefined; // Stores the currently active mutation\n\n  // Each `useThreads` with unique filter options creates its own revalidation manager that is used during the initial revalidation.\n  const revalidationManagerByOptions = new Map<\n    string,\n    UseThreadsRevalidationManager<TThreadMetadata>\n  >();\n\n  // Keep track of how many times each revalidation manager is used.\n  const referenceCountByOptions = new Map<string, number>();\n\n  return {\n    // Cache\n    getCache() {\n      const threads = getCache();\n      // Filter the cache to only include threads that are in the current room\n      const filtered = threads.filter((thread) => thread.roomId === roomId);\n      return filtered;\n    },\n    setCache(value: ThreadData<TThreadMetadata>[]) {\n      // Delete any revalidation managers that are no longer used by any `useThreads` hooks\n      for (const key of revalidationManagerByOptions.keys()) {\n        if (referenceCountByOptions.get(key) === 0) {\n          revalidationManagerByOptions.delete(key);\n          referenceCountByOptions.delete(key);\n        }\n      }\n\n      // Sort the threads by createdAt date before updating the cache\n      const sorted = value.sort(\n        (a, b) =>\n          new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n      );\n\n      const threads = getCache();\n      const newThreads = threads\n        .filter((thread) => thread.roomId !== roomId)\n        .concat(sorted);\n\n      setCache(newThreads);\n    },\n\n    // Request\n    getRequest() {\n      return request;\n    },\n    setRequest(value: RequestInfo<ThreadData<TThreadMetadata>[]> | undefined) {\n      request = value;\n    },\n\n    // Error\n    getError() {\n      return error;\n    },\n    setError(err: Error) {\n      error = err;\n    },\n\n    // Mutation\n    getMutation() {\n      return mutation;\n    },\n    setMutation(info: MutationInfo) {\n      mutation = info;\n    },\n\n    getRevalidationManagers() {\n      return Array.from(revalidationManagerByOptions.entries());\n    },\n\n    getRevalidationManager(key: string) {\n      return revalidationManagerByOptions.get(key);\n    },\n\n    setRevalidationmanager(\n      key: string,\n      manager: UseThreadsRevalidationManager<TThreadMetadata>\n    ) {\n      revalidationManagerByOptions.set(key, manager);\n    },\n\n    getTotalReferenceCount() {\n      return Array.from(referenceCountByOptions.values()).reduce(\n        (acc, count) => acc + count,\n        0\n      );\n    },\n\n    incrementReferenceCount(key: string) {\n      const count = referenceCountByOptions.get(key) ?? 0;\n      referenceCountByOptions.set(key, count + 1);\n    },\n\n    decrementReferenceCount(key: string) {\n      const count = referenceCountByOptions.get(key) ?? 0;\n      referenceCountByOptions.set(key, count - 1);\n    },\n\n    getReferenceCount(key: string) {\n      return referenceCountByOptions.get(key) ?? 0;\n    },\n  };\n}\n\nexport function createThreadsCacheManager<\n  TThreadMetadata extends BaseMetadata,\n>(): ThreadsCacheManager<TThreadMetadata> {\n  let cache: ThreadData<TThreadMetadata>[] | undefined; // Stores the current cache state\n  let request: RequestInfo<ThreadData<TThreadMetadata>[]> | undefined; // Stores the currently active revalidation request\n  let error: Error | undefined; // Stores any error that occurred during the last revalidation request\n  let mutation: MutationInfo | undefined; // Stores the start and end time of the currently active mutation\n\n  // Create an event source to notify subscribers when the cache is updated\n  const cacheEventSource = makeEventSource<ThreadData<TThreadMetadata>[]>();\n\n  // Create an event source to notify subscribers when there is an error\n  const errorEventSource = makeEventSource<Error>();\n\n  return {\n    // Cache\n    getCache() {\n      return cache;\n    },\n    setCache(value: ThreadData<TThreadMetadata>[]) {\n      // Because the cache can be set as a result of a fetcher that makes multiple `getThreads` calls in parallel, we aren't sure the final thread results are sorted by date, so we do it here.\n      const sorted = value.sort(\n        (a, b) =>\n          new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n      );\n\n      cache = sorted;\n      // Notify subscribers that the cache has been updated\n      cacheEventSource.notify(cache);\n    },\n\n    // Request\n    getRequest() {\n      return request;\n    },\n    setRequest(value: RequestInfo<ThreadData<TThreadMetadata>[]> | undefined) {\n      request = value;\n    },\n\n    // Error\n    getError() {\n      return error;\n    },\n    setError(err: Error) {\n      error = err;\n      // Notify subscribers that there was an error\n      errorEventSource.notify(err);\n    },\n\n    // Mutation\n    getMutation() {\n      return mutation;\n    },\n    setMutation(info: MutationInfo) {\n      mutation = info;\n    },\n\n    // Subscription\n    subscribe(\n      type: \"cache\" | \"error\",\n      callback:\n        | ((state: ThreadData<TThreadMetadata>[]) => void)\n        | ((error: Error) => void)\n    ) {\n      switch (type) {\n        case \"cache\":\n          return cacheEventSource.subscribe(\n            callback as (state: ThreadData<TThreadMetadata>[]) => void\n          );\n        case \"error\":\n          return errorEventSource.subscribe(callback as (error: Error) => void);\n      }\n    },\n  };\n}\n\nfunction createClientCacheStore<TThreadMetadata extends BaseMetadata>() {\n  let threads: ThreadData<TThreadMetadata>[] = []; // Stores the current threads cache state\n\n  // Create an event source to notify subscribers when the cache is updated\n  const threadsEventSource = makeEventSource<ThreadData<TThreadMetadata>[]>();\n\n  return {\n    getThreads() {\n      return threads;\n    },\n    setThreads(value: ThreadData<TThreadMetadata>[]) {\n      threads = value;\n      // Notify subscribers that the threads cache has been updated\n      threadsEventSource.notify(threads);\n    },\n\n    subscribe(callback: (state: ThreadData<TThreadMetadata>[]) => void) {\n      return threadsEventSource.subscribe(callback);\n    },\n  };\n}\n\nfunction createUseThreadsRevalidationManager<\n  TThreadMetadata extends BaseMetadata,\n>(\n  options: GetThreadsOptions<TThreadMetadata>,\n  manager: ReturnType<typeof createRoomRevalidationManager<TThreadMetadata>>\n): UseThreadsRevalidationManager<TThreadMetadata> {\n  let isLoading: boolean = true;\n  let request: RequestInfo<ThreadData<TThreadMetadata>[]> | undefined; // Stores the currently active revalidation request\n  let error: Error | undefined; // Stores any error that occurred during the last revalidation request\n\n  return {\n    // Cache\n    getCache() {\n      return undefined;\n    },\n    setCache(value: ThreadData<TThreadMetadata>[]) {\n      const cache = new Map(\n        (manager.getCache() ?? []).map((thread) => [thread.id, thread])\n      );\n\n      for (const thread of value) {\n        cache.set(thread.id, thread);\n      }\n      manager.setCache(Array.from(cache.values()));\n\n      isLoading = false;\n    },\n\n    // Request\n    getRequest() {\n      return request;\n    },\n    setRequest(value: RequestInfo<ThreadData<TThreadMetadata>[]> | undefined) {\n      request = value;\n    },\n\n    // Error\n    getError() {\n      return error;\n    },\n    setError(err: Error) {\n      error = err;\n      isLoading = false;\n      const cache = manager.getCache();\n      manager.setCache(cache);\n    },\n\n    // Mutation\n    getMutation() {\n      // useThreads revalidation manager need not get the current mutation\n      return undefined;\n    },\n    setMutation(_: MutationInfo) {\n      // useThreads revalidation manager need not set mutations\n      return;\n    },\n\n    getOptions() {\n      return options;\n    },\n\n    getIsLoading() {\n      return isLoading;\n    },\n\n    setIsLoading(value: boolean) {\n      isLoading = value;\n    },\n  };\n}\n\n/**\n * Returns the polling interval based on the room connection status, the browser online status and the document visibility.\n * @param isBrowserOnline Whether the browser is online.\n * @param isDocumentVisible Whether the document is visible.\n * @param isRoomConnected Whether the room is connected.\n * @returns The polling interval in milliseconds or undefined if we don't poll the server.\n */\nfunction getPollingInterval(\n  isBrowserOnline: boolean,\n  isDocumentVisible: boolean,\n  isRoomConnected: boolean\n): number | undefined {\n  // If the browser is offline or the document is not visible, we don't poll the server.\n  if (!isBrowserOnline || !isDocumentVisible) return;\n\n  // If the room is connected, we poll the server in real-time.\n  if (isRoomConnected) return POLLING_INTERVAL_REALTIME;\n\n  // (Otherwise) If the room is not connected, we poll the server at POLLING_INTERVAL rate.\n  return POLLING_INTERVAL;\n}\n","import type { BaseMetadata, CommentBody } from \"@liveblocks/core\";\n\ntype PartialNullable<T> = {\n  [P in keyof T]?: T[P] | null | undefined;\n};\n\nexport class CreateThreadError<TMetadata extends BaseMetadata> extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n      metadata: TMetadata;\n    }\n  ) {\n    super(\"Create thread failed.\");\n    this.name = \"CreateThreadError\";\n  }\n}\n\nexport class EditThreadMetadataError<\n  TMetadata extends BaseMetadata,\n> extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      metadata: PartialNullable<TMetadata>;\n    }\n  ) {\n    super(\"Edit thread metadata failed.\");\n    this.name = \"EditThreadMetadataError\";\n  }\n}\n\nexport class CreateCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n    }\n  ) {\n    super(\"Create comment failed.\");\n    this.name = \"CreateCommentError\";\n  }\n}\n\nexport class EditCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n    }\n  ) {\n    super(\"Edit comment failed.\");\n    this.name = \"EditCommentError\";\n  }\n}\n\nexport class DeleteCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n    }\n  ) {\n    super(\"Delete comment failed.\");\n    this.name = \"DeleteCommentError\";\n  }\n}\n\nexport class AddReactionError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  ) {\n    super(\"Add reaction failed.\");\n    this.name = \"AddReactionError\";\n  }\n}\n\nexport class RemoveReactionError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  ) {\n    super(\"Remove reaction failed.\");\n    this.name = \"RemoveReactionError\";\n  }\n}\n\nexport type CommentsError<TThreadMetadata extends BaseMetadata> =\n  | CreateThreadError<TThreadMetadata>\n  | EditThreadMetadataError<TThreadMetadata>\n  | CreateCommentError\n  | EditCommentError\n  | DeleteCommentError;\n","/**\n * This implementation is inspired by the `swr` library.\n * Additional modifications were made to adapt it to our specific needs.\n *\n * Original `swr` library can be found at [SWR GitHub repository](https://github.com/vercel/swr)\n */\n\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport useIsDocumentVisible from \"./use-is-document-visible\";\nimport useIsOnline from \"./use-is-online\";\n\nconst DEFAULT_ERROR_RETRY_INTERVAL = 5000;\nconst DEFAULT_MAX_ERROR_RETRY_COUNT = 5;\nconst DEFAULT_DEDUPING_INTERVAL = 2000;\n\nexport type CacheState<Data> =\n  | {\n      isLoading: true;\n      data?: never;\n      error?: never;\n    }\n  | {\n      isLoading: false;\n      data?: Data;\n      error?: Error;\n    };\n\nexport type RequestInfo<Data> = {\n  fetcher: Promise<Data>;\n  timestamp: number;\n};\n\nexport type MutationInfo = {\n  startTime: number;\n  endTime: number;\n};\n\nexport interface CacheManager<Data> {\n  // Cache\n  getCache(): Data | undefined;\n  setCache(data: Data | undefined): void;\n\n  // Error\n  getError(): Error | undefined;\n  setError(error: Error): void;\n\n  // Request\n  getRequest(): RequestInfo<Data> | undefined;\n  setRequest(request: RequestInfo<Data> | undefined): void;\n\n  // Mutation\n  getMutation(): MutationInfo | undefined;\n  setMutation(mutation: MutationInfo): void;\n}\n\nlet timestamp = 0;\n\n/**\n * This hook returns a function that can be used to revalidate the cache.\n * @param manager - The cache manager\n * @param fetcher - The function used to fetch the data\n * @param options.dedupingInterval - The interval (in milliseconds) at which requests should be deduped.\n * @param options.errorRetryInterval - The interval (in milliseconds) at which failed requests should be retried.\n * @param options.errorRetryCount - The maximum number of times a request should be retried.\n * @returns A function that can be used to revalidate the cache\n */\nexport function useRevalidateCache<Data>(\n  manager: CacheManager<Data>,\n  fetcher: () => Promise<Data>,\n  options: {\n    dedupingInterval?: number;\n    errorRetryInterval?: number;\n    errorRetryCount?: number;\n  } = {}\n) {\n  const isOnlineRef = useRef(true); // Stores the current online status of the browser\n\n  const {\n    dedupingInterval = DEFAULT_DEDUPING_INTERVAL,\n    errorRetryInterval = DEFAULT_ERROR_RETRY_INTERVAL,\n    errorRetryCount = DEFAULT_MAX_ERROR_RETRY_COUNT,\n  } = options;\n\n  /**\n   * Revalidates the cache and optionally dedupes the request.\n   * @param shouldDedupe - If true, the request will be deduped\n   * @param retryCount - The number of times the request has been retried (used for exponential backoff)\n   */\n  const _revalidateCache = useCallback(\n    async ({\n      shouldDedupe,\n      retryCount = 0,\n    }: {\n      shouldDedupe: boolean;\n      retryCount: number;\n    }) => {\n      let startAt: number;\n\n      // A new request should be started if there is no ongoing request OR if `shouldDedupe` is false\n      const shouldStartRequest = !manager.getRequest() || !shouldDedupe;\n\n      function deleteActiveRequest() {\n        const activeRequest = manager.getRequest();\n        if (!activeRequest) return;\n\n        if (activeRequest.timestamp !== startAt) return;\n        manager.setRequest(undefined);\n      }\n\n      // Uses the exponential backoff algorithm to retry the request on error.\n      function handleError() {\n        const timeout =\n          ~~((Math.random() + 0.5) * (1 << (retryCount < 8 ? retryCount : 8))) *\n          errorRetryInterval;\n\n        if (retryCount > errorRetryCount) return;\n\n        setTimeout(() => {\n          void _revalidateCache({\n            shouldDedupe: false,\n            retryCount: retryCount + 1,\n          });\n        }, timeout);\n      }\n\n      if (shouldStartRequest) {\n        manager.setRequest({\n          fetcher: fetcher(),\n          timestamp: ++timestamp,\n        });\n      }\n\n      try {\n        let activeRequest = manager.getRequest();\n        if (!activeRequest) return;\n\n        startAt = activeRequest.timestamp;\n\n        const newData = await activeRequest.fetcher;\n\n        if (shouldStartRequest) {\n          setTimeout(deleteActiveRequest, dedupingInterval);\n        }\n\n        activeRequest = manager.getRequest();\n        // If there was a newer revalidation request (or if the current request was removed due to a mutation), while this request was in flight, we return early and don't update the cache (since the revalidation request is outdated)\n        if (!activeRequest || activeRequest.timestamp !== startAt) return;\n\n        // If there is an active mutation, we ignore the revalidation result as it is outdated (and because the mutation will trigger a revalidation)\n        const activeMutation = manager.getMutation();\n        if (\n          activeMutation &&\n          (activeMutation.startTime > startAt ||\n            activeMutation.endTime > startAt ||\n            activeMutation.endTime === 0)\n        ) {\n          return;\n        }\n\n        manager.setCache(newData);\n      } catch (err) {\n        deleteActiveRequest();\n\n        // Only retry revalidation if the browser is online and the current document is visible. We auto-revalidate when the browser comes back online.\n        const isVisible = document.visibilityState === \"visible\";\n        const isOnline = isOnlineRef.current;\n\n        if (shouldStartRequest && isVisible && isOnline) handleError();\n\n        manager.setError(err as Error);\n      }\n      return;\n    },\n    [manager, fetcher, dedupingInterval, errorRetryInterval, errorRetryCount]\n  );\n\n  /**\n   * Subscribe to online and offline events and update the `isOnlineRef` accordingly. This is used to determine whether or not to retry a request on error.\n   * Note: There is a 'navigator.onLine' property that can be used to determine the online status of the browser, but it is not reliable (see https://bugs.chromium.org/p/chromium/issues/detail?id=678075).\n   */\n  useEffect(() => {\n    function handleIsOnline() {\n      isOnlineRef.current = true;\n    }\n\n    function handleIsOffline() {\n      isOnlineRef.current = false;\n    }\n\n    window.addEventListener(\"online\", handleIsOnline);\n    window.addEventListener(\"offline\", handleIsOffline);\n    return () => {\n      window.removeEventListener(\"online\", handleIsOnline);\n      window.removeEventListener(\"offline\", handleIsOffline);\n    };\n  }, []);\n\n  const revalidateCache = useCallback(\n    ({ shouldDedupe }: { shouldDedupe: boolean }) => {\n      return _revalidateCache({ shouldDedupe, retryCount: 0 });\n    },\n    [_revalidateCache]\n  );\n\n  return revalidateCache;\n}\n\n/**\n * This hook returns a function that can be used to mutate the cache with optimistic data. The cache will be reverted to its previous state if the mutation request fails.\n * @param manager - The cache manager\n * @param revalidateCache - The function used to revalidate the cache\n * @returns A function that can be used to mutate the cache with optimistic data\n */\nexport function useMutate<Data>(\n  manager: CacheManager<Data>,\n  revalidateCache: ({\n    shouldDedupe,\n  }: {\n    shouldDedupe: boolean;\n  }) => Promise<void>\n) {\n  const mutate = useCallback(\n    async (\n      data: Promise<any>,\n      options: {\n        optimisticData: Data;\n      }\n    ) => {\n      const beforeMutationTimestamp = ++timestamp;\n      manager.setMutation({\n        startTime: beforeMutationTimestamp,\n        endTime: 0,\n      });\n\n      const currentCache = manager.getCache();\n\n      // Update the cache with the optimistic data\n      manager.setCache(options.optimisticData);\n\n      let error: unknown;\n\n      try {\n        await data;\n      } catch (err) {\n        error = err;\n      }\n\n      // If there was a newer mutation while this mutation was in flight, we return early and don't trigger a revalidation (since the mutation request is outdated)\n      const activeMutation = manager.getMutation();\n      if (\n        activeMutation &&\n        beforeMutationTimestamp !== activeMutation.startTime\n      ) {\n        if (error) throw error;\n        return;\n      }\n\n      // If the mutation request failed, revert the optimistic update\n      if (error) {\n        manager.setCache(currentCache);\n      }\n\n      // Mark the mutation as completed by setting the end time to the current timestamp\n      manager.setMutation({\n        startTime: beforeMutationTimestamp,\n        endTime: ++timestamp,\n      });\n\n      // Deleting the concurrent request markers so new requests will not be deduped.\n      manager.setRequest(undefined);\n\n      // Trigger a revalidation request to update the cache with the latest data\n      void revalidateCache({ shouldDedupe: false });\n\n      // Throw the error if the mutation request failed\n      if (error) throw error;\n    },\n    [manager, revalidateCache]\n  );\n\n  return mutate;\n}\n\n/**\n * This hook automatically revalidates the cache when the browser comes back online, when the document becomes visible, or periodically.\n * @param manager - The cache manager\n * @param revalidateCache - The function used to revalidate the cache\n * @param options.revalidateOnFocus - If true, the cache will be revalidated when the document becomes visible\n * @param options.revalidateOnReconnect - If true, the cache will be revalidated when the browser comes back online\n * @param options.refreshInterval - The interval (in milliseconds) at which the cache should be revalidated. If set to 0, the cache will not be revalidated periodically\n */\nexport function useAutomaticRevalidation<Data>(\n  manager: CacheManager<Data>,\n  revalidateCache: ({\n    shouldDedupe,\n  }: {\n    shouldDedupe: boolean;\n  }) => Promise<void>,\n  options: {\n    revalidateOnFocus?: boolean;\n    revalidateOnReconnect?: boolean;\n    refreshInterval?: number;\n  } = {}\n) {\n  const isOnline = useIsOnline(); // Stores the current online status of the browser\n  const isDocumentVisible = useIsDocumentVisible(); // Stores the current visibility status of the document\n\n  const {\n    revalidateOnFocus = true,\n    revalidateOnReconnect = true,\n    refreshInterval = 0,\n  } = options;\n\n  /**\n   * Periodically revalidate the cache. The revalidation is skipped if the browser is offline or if the document is not visible.\n   */\n  useEffect(() => {\n    let revalidationTimerId: number;\n\n    function scheduleRevalidation() {\n      if (refreshInterval === 0) return;\n\n      revalidationTimerId = window.setTimeout(() => {\n        // Only revalidate if the browser is online AND document is visible AND there are currently no errors, otherwise schedule the next revalidation\n        if (isOnline && isDocumentVisible && !manager.getError()) {\n          // Revalidate cache and then schedule the next revalidation\n          void revalidateCache({ shouldDedupe: true }).then(\n            scheduleRevalidation\n          );\n          return;\n        }\n\n        scheduleRevalidation();\n      }, refreshInterval);\n    }\n\n    // Schedule the first revalidation\n    scheduleRevalidation();\n\n    return () => {\n      window.clearTimeout(revalidationTimerId);\n    };\n  }, [revalidateCache, refreshInterval, isOnline, isDocumentVisible, manager]);\n\n  /**\n   * Subscribe to the 'online' event to trigger a revalidation when the browser comes back online.\n   * Note: There is a 'navigator.onLine' property that can be used to determine the online status of the browser, but it is not reliable (see https://bugs.chromium.org/p/chromium/issues/detail?id=678075).\n   */\n  useEffect(() => {\n    function handleIsOnline() {\n      if (revalidateOnReconnect && isDocumentVisible) {\n        void revalidateCache({ shouldDedupe: true });\n      }\n    }\n\n    window.addEventListener(\"online\", handleIsOnline);\n    return () => {\n      window.removeEventListener(\"online\", handleIsOnline);\n    };\n  }, [revalidateCache, revalidateOnReconnect, isDocumentVisible]);\n\n  /**\n   * Subscribe to visibility change events to trigger a revalidation when the document becomes visible.\n   */\n  useEffect(() => {\n    function handleVisibilityChange() {\n      const isVisible = document.visibilityState === \"visible\";\n      if (revalidateOnFocus && isVisible && isOnline) {\n        void revalidateCache({ shouldDedupe: true });\n      }\n    }\n\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    return () => {\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n    };\n  }, [revalidateCache, revalidateOnFocus, isOnline]);\n}\n","import { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nexport default function useIsDocumentVisible() {\n  const isVisible = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n  return isVisible;\n}\n\nfunction subscribe(onStoreChange: () => void) {\n  document.addEventListener(\"visibilitychange\", onStoreChange);\n  return () => {\n    document.removeEventListener(\"visibilitychange\", onStoreChange);\n  };\n}\n\nfunction getSnapshot() {\n  const isDocumentDefined = typeof document !== \"undefined\";\n  return isDocumentDefined ? document.visibilityState === \"visible\" : true;\n}\n","import { useCallback, useRef } from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nexport default function useIsOnline() {\n  const isOnlineRef = useRef(true);\n\n  /**\n   * Note: There is a 'navigator.onLine' property that can be used to determine the online status of the browser, but it is not reliable (see https://bugs.chromium.org/p/chromium/issues/detail?id=678075).\n   */\n  const subscribe = useCallback((onStoreChange: () => void) => {\n    function handleIsOnline() {\n      isOnlineRef.current = true;\n      onStoreChange();\n    }\n\n    function handleIsOffline() {\n      isOnlineRef.current = false;\n      onStoreChange();\n    }\n\n    window.addEventListener(\"online\", handleIsOnline);\n    window.addEventListener(\"offline\", handleIsOffline);\n    return () => {\n      window.removeEventListener(\"online\", handleIsOnline);\n      window.removeEventListener(\"offline\", handleIsOffline);\n    };\n  }, []);\n\n  const getSnapshot = useCallback(() => {\n    return isOnlineRef.current;\n  }, []);\n\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n  return isOnline;\n}\n","import { useEffect, useRef, useState } from \"react\";\n\nconst DEFAULT_DELAY = 500;\n\nexport function useDebounce<T>(\n  value: T,\n  delay: number | false = DEFAULT_DELAY\n): T {\n  const timeout = useRef<number>();\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    if (delay === false) {\n      return;\n    }\n\n    if (timeout.current === undefined) {\n      setDebouncedValue(value);\n    }\n\n    timeout.current = window.setTimeout(() => {\n      setDebouncedValue(value);\n      timeout.current = undefined;\n    }, delay);\n\n    return () => {\n      window.clearTimeout(timeout.current);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n","import type {\n  AsyncCache,\n  AsyncState,\n  AsyncStateInitial,\n  AsyncStateResolved,\n} from \"@liveblocks/core\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nimport { useInitial } from \"./use-initial\";\n\nconst INITIAL_ASYNC_STATE: AsyncStateInitial = {\n  isLoading: false,\n  data: undefined,\n  error: undefined,\n};\n\nexport type UseAsyncCacheOptions = {\n  keepPreviousDataWhileLoading?: boolean;\n  suspense?: boolean;\n};\n\ntype UseAsyncCacheState<\n  T,\n  E,\n  O extends UseAsyncCacheOptions = UseAsyncCacheOptions,\n> = O extends {\n  suspense: true;\n}\n  ? Exclude<AsyncState<T, E>, { isLoading: true }>\n  : AsyncState<T, E>;\n\nexport type UseAsyncCacheResponse<\n  T,\n  E,\n  O extends UseAsyncCacheOptions = UseAsyncCacheOptions,\n> = UseAsyncCacheState<T, E, O> & {\n  /**\n   * Returns the current state of the key synchronously.\n   */\n  getState: () => AsyncState<T, E>;\n\n  /**\n   * Revalidates the key.\n   */\n  revalidate(): Promise<AsyncStateResolved<T, E>>;\n};\n\ntype PreviousData<T> = {\n  key: string | null;\n  data?: T;\n};\n\nconst noop = () => {};\n\nexport function useAsyncCache<T, E, O extends UseAsyncCacheOptions>(\n  cache: AsyncCache<T, E> | undefined,\n  key: string | null,\n  options?: O\n): UseAsyncCacheResponse<T, E, O> {\n  const frozenOptions = useInitial(options);\n  const cacheItem = useMemo(() => {\n    if (key === null || !cache) {\n      return null;\n    }\n\n    const cacheItem = cache.create(key);\n    void cacheItem.get();\n\n    return cacheItem;\n  }, [cache, key]);\n\n  const subscribe = useCallback(\n    (callback: () => void) => cacheItem?.subscribe(callback) ?? noop,\n    [cacheItem]\n  );\n\n  const getState = useCallback(\n    () => cacheItem?.getState() ?? INITIAL_ASYNC_STATE,\n    [cacheItem]\n  );\n\n  const revalidate = useCallback(() => cacheItem?.revalidate(), [cacheItem]);\n\n  const state = useSyncExternalStore(subscribe, getState, getState);\n  const previousData = useRef<PreviousData<T>>();\n  let data = state.data;\n\n  useEffect(() => {\n    previousData.current = { key, data: state.data };\n  }, [key, state.data]);\n\n  if (!cacheItem) {\n    return {\n      isLoading: false,\n      data: undefined,\n      error: undefined,\n      getState,\n      revalidate,\n    } as UseAsyncCacheResponse<T, E, O>;\n  }\n\n  if (frozenOptions?.suspense) {\n    const error = getState().error;\n\n    if (error) {\n      throw error;\n    } else if (getState().isLoading) {\n      throw new Promise<void>((resolve) => {\n        cacheItem.subscribeOnce((state) => {\n          if (!state.isLoading) {\n            resolve();\n          }\n        });\n      });\n    }\n  }\n\n  if (\n    state.isLoading &&\n    frozenOptions?.keepPreviousDataWhileLoading &&\n    typeof state.data === \"undefined\" &&\n    previousData.current?.key !== key &&\n    typeof previousData.current?.data !== \"undefined\"\n  ) {\n    data = previousData.current.data;\n  }\n\n  return {\n    isLoading: state.isLoading,\n    data,\n    error: state.error,\n    getState,\n    revalidate,\n  } as UseAsyncCacheResponse<T, E, O>;\n}\n","import { useState } from \"react\";\n\n/**\n * \"Freezes\" a given value, so that it will return the same value/instance on\n * each subsequent render. This can be used to freeze \"initial\" values for\n * custom hooks, much like how `useState(initialState)` or\n * `useRef(initialValue)` works.\n */\nexport function useInitial<T>(value: T): T {\n  return useState(value)[0];\n}\n","import { useEffect, useRef } from \"react\";\n\n/**\n * Keeps a ref in sync with a given value that may or may not change on\n * every render.\n *\n * The purpose of this hook is to return a stable ref that can be passed\n * to a callback function so the callback can be registered but still can\n * access the latest value at a later point in time.\n */\nexport function useLatest<T>(value: T): { readonly current: T } {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n","import { useReducer } from \"react\";\n\n/**\n * Trigger a re-render programmatically, without changing the component's\n * state.\n *\n * @example\n * const rerender = useRerender();\n *\n * return (\n *   <button onClick={rerender}>\n *     {Math.random()}\n *   </button>\n * )\n */\nexport function useRerender(): () => void {\n  const [, update] = useReducer(\n    // This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x: number): number => x + 1,\n    0\n  );\n  return update;\n}\n"],"mappings":";;;AAAA,SAAS,mBAAmB;;;ACGrB,IAAM,WAAW;AACjB,IAAM,cAAiD;AACvD,IAAM,aAAgD;;;ACJ7D,YAAY,WAAW;AAwBhB,SAAS,mBAAmB,OAA4B;AAC7D,QAAM,CAAC,SAAS,UAAU,IAAU,eAAS,KAAK;AAElD,EAAM,gBAAU,MAAM;AAGpB,eAAW,IAAI;AAAA,EACjB,GAAG,CAAC,CAAC;AAEL,SACE,oCAAO,gBAAN,EAAe,UAAU,MAAM,YAC7B,UAAU,MAAM,SAAS,IAAI,MAAM,QACtC;AAEJ;;;ACxBA,SAAS,eAAe;AAUxB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,mBAAAA;AAAA,EACA,aAAAC;AAAA,OACK;AACP,YAAYC,YAAW;AACvB,SAAS,oCAAAC,yCAAwC;;;ACnBjD,SAAS,kBAAkB,iBAAiB,iBAAiB;AAC7D,SAAS,cAAc;AAEvB,OAAOC;AAAA,EACL;AAAA,EACA,eAAAC;AAAA,EACA;AAAA,EACA,aAAAC;AAAA,EACA;AAAA,OACK;AACP,SAAS,wCAAwC;;;ACnB1C,IAAM,oBAAN,cAAgE,MAAM;AAAA,EAC3E,YACS,OACA,SAOP;AACA,UAAM,uBAAuB;AATtB;AACA;AASP,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,0BAAN,cAEG,MAAM;AAAA,EACd,YACS,OACA,SAKP;AACA,UAAM,8BAA8B;AAP7B;AACA;AAOP,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,qBAAN,cAAiC,MAAM;AAAA,EAC5C,YACS,OACA,SAMP;AACA,UAAM,wBAAwB;AARvB;AACA;AAQP,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,mBAAN,cAA+B,MAAM;AAAA,EAC1C,YACS,OACA,SAMP;AACA,UAAM,sBAAsB;AARrB;AACA;AAQP,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,qBAAN,cAAiC,MAAM;AAAA,EAC5C,YACS,OACA,SAKP;AACA,UAAM,wBAAwB;AAPvB;AACA;AAOP,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,mBAAN,cAA+B,MAAM;AAAA,EAC1C,YACS,OACA,SAMP;AACA,UAAM,sBAAsB;AARrB;AACA;AAQP,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,sBAAN,cAAkC,MAAM;AAAA,EAC7C,YACS,OACA,SAMP;AACA,UAAM,yBAAyB;AARxB;AACA;AAQP,SAAK,OAAO;AAAA,EACd;AACF;;;ACvGA,SAAS,eAAAC,cAAa,aAAAC,YAAW,UAAAC,eAAc;;;ACP/C,SAAS,4BAA4B;AAEtB,SAAR,uBAAwC;AAC7C,QAAM,YAAY,qBAAqB,WAAW,aAAa,WAAW;AAC1E,SAAO;AACT;AAEA,SAAS,UAAU,eAA2B;AAC5C,WAAS,iBAAiB,oBAAoB,aAAa;AAC3D,SAAO,MAAM;AACX,aAAS,oBAAoB,oBAAoB,aAAa;AAAA,EAChE;AACF;AAEA,SAAS,cAAc;AACrB,QAAM,oBAAoB,OAAO,aAAa;AAC9C,SAAO,oBAAoB,SAAS,oBAAoB,YAAY;AACtE;;;ACjBA,SAAS,aAAa,cAAc;AACpC,SAAS,wBAAAC,6BAA4B;AAEtB,SAAR,cAA+B;AACpC,QAAM,cAAc,OAAO,IAAI;AAK/B,QAAMC,aAAY,YAAY,CAAC,kBAA8B;AAC3D,aAAS,iBAAiB;AACxB,kBAAY,UAAU;AACtB,oBAAc;AAAA,IAChB;AAEA,aAAS,kBAAkB;AACzB,kBAAY,UAAU;AACtB,oBAAc;AAAA,IAChB;AAEA,WAAO,iBAAiB,UAAU,cAAc;AAChD,WAAO,iBAAiB,WAAW,eAAe;AAClD,WAAO,MAAM;AACX,aAAO,oBAAoB,UAAU,cAAc;AACnD,aAAO,oBAAoB,WAAW,eAAe;AAAA,IACvD;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAMC,eAAc,YAAY,MAAM;AACpC,WAAO,YAAY;AAAA,EACrB,GAAG,CAAC,CAAC;AAEL,QAAM,WAAWF,sBAAqBC,YAAWC,cAAaA,YAAW;AACzE,SAAO;AACT;;;AFtBA,IAAM,+BAA+B;AACrC,IAAM,gCAAgC;AACtC,IAAM,4BAA4B;AA0ClC,IAAI,YAAY;AAWT,SAAS,mBACd,SACA,SACA,UAII,CAAC,GACL;AACA,QAAM,cAAcC,QAAO,IAAI;AAE/B,QAAM;AAAA,IACJ,mBAAmB;AAAA,IACnB,qBAAqB;AAAA,IACrB,kBAAkB;AAAA,EACpB,IAAI;AAOJ,QAAM,mBAAmBC;AAAA,IACvB,OAAO;AAAA,MACL;AAAA,MACA,aAAa;AAAA,IACf,MAGM;AACJ,UAAI;AAGJ,YAAM,qBAAqB,CAAC,QAAQ,WAAW,KAAK,CAAC;AAErD,eAAS,sBAAsB;AAC7B,cAAM,gBAAgB,QAAQ,WAAW;AACzC,YAAI,CAAC;AAAe;AAEpB,YAAI,cAAc,cAAc;AAAS;AACzC,gBAAQ,WAAW,MAAS;AAAA,MAC9B;AAGA,eAAS,cAAc;AACrB,cAAM,UACJ,CAAC,GAAG,KAAK,OAAO,IAAI,QAAQ,MAAM,aAAa,IAAI,aAAa,OAChE;AAEF,YAAI,aAAa;AAAiB;AAElC,mBAAW,MAAM;AACf,eAAK,iBAAiB;AAAA,YACpB,cAAc;AAAA,YACd,YAAY,aAAa;AAAA,UAC3B,CAAC;AAAA,QACH,GAAG,OAAO;AAAA,MACZ;AAEA,UAAI,oBAAoB;AACtB,gBAAQ,WAAW;AAAA,UACjB,SAAS,QAAQ;AAAA,UACjB,WAAW,EAAE;AAAA,QACf,CAAC;AAAA,MACH;AAEA,UAAI;AACF,YAAI,gBAAgB,QAAQ,WAAW;AACvC,YAAI,CAAC;AAAe;AAEpB,kBAAU,cAAc;AAExB,cAAM,UAAU,MAAM,cAAc;AAEpC,YAAI,oBAAoB;AACtB,qBAAW,qBAAqB,gBAAgB;AAAA,QAClD;AAEA,wBAAgB,QAAQ,WAAW;AAEnC,YAAI,CAAC,iBAAiB,cAAc,cAAc;AAAS;AAG3D,cAAM,iBAAiB,QAAQ,YAAY;AAC3C,YACE,mBACC,eAAe,YAAY,WAC1B,eAAe,UAAU,WACzB,eAAe,YAAY,IAC7B;AACA;AAAA,QACF;AAEA,gBAAQ,SAAS,OAAO;AAAA,MAC1B,SAAS,KAAK;AACZ,4BAAoB;AAGpB,cAAM,YAAY,SAAS,oBAAoB;AAC/C,cAAM,WAAW,YAAY;AAE7B,YAAI,sBAAsB,aAAa;AAAU,sBAAY;AAE7D,gBAAQ,SAAS,GAAY;AAAA,MAC/B;AACA;AAAA,IACF;AAAA,IACA,CAAC,SAAS,SAAS,kBAAkB,oBAAoB,eAAe;AAAA,EAC1E;AAMA,EAAAC,WAAU,MAAM;AACd,aAAS,iBAAiB;AACxB,kBAAY,UAAU;AAAA,IACxB;AAEA,aAAS,kBAAkB;AACzB,kBAAY,UAAU;AAAA,IACxB;AAEA,WAAO,iBAAiB,UAAU,cAAc;AAChD,WAAO,iBAAiB,WAAW,eAAe;AAClD,WAAO,MAAM;AACX,aAAO,oBAAoB,UAAU,cAAc;AACnD,aAAO,oBAAoB,WAAW,eAAe;AAAA,IACvD;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,kBAAkBD;AAAA,IACtB,CAAC,EAAE,aAAa,MAAiC;AAC/C,aAAO,iBAAiB,EAAE,cAAc,YAAY,EAAE,CAAC;AAAA,IACzD;AAAA,IACA,CAAC,gBAAgB;AAAA,EACnB;AAEA,SAAO;AACT;AAQO,SAAS,UACd,SACA,iBAKA;AACA,QAAM,SAASA;AAAA,IACb,OACE,MACA,YAGG;AACH,YAAM,0BAA0B,EAAE;AAClC,cAAQ,YAAY;AAAA,QAClB,WAAW;AAAA,QACX,SAAS;AAAA,MACX,CAAC;AAED,YAAM,eAAe,QAAQ,SAAS;AAGtC,cAAQ,SAAS,QAAQ,cAAc;AAEvC,UAAI;AAEJ,UAAI;AACF,cAAM;AAAA,MACR,SAAS,KAAK;AACZ,gBAAQ;AAAA,MACV;AAGA,YAAM,iBAAiB,QAAQ,YAAY;AAC3C,UACE,kBACA,4BAA4B,eAAe,WAC3C;AACA,YAAI;AAAO,gBAAM;AACjB;AAAA,MACF;AAGA,UAAI,OAAO;AACT,gBAAQ,SAAS,YAAY;AAAA,MAC/B;AAGA,cAAQ,YAAY;AAAA,QAClB,WAAW;AAAA,QACX,SAAS,EAAE;AAAA,MACb,CAAC;AAGD,cAAQ,WAAW,MAAS;AAG5B,WAAK,gBAAgB,EAAE,cAAc,MAAM,CAAC;AAG5C,UAAI;AAAO,cAAM;AAAA,IACnB;AAAA,IACA,CAAC,SAAS,eAAe;AAAA,EAC3B;AAEA,SAAO;AACT;;;AF3OA,IAAM,mBAAmB;AACzB,IAAM,oBAAoB;AAEnB,IAAM,4BAA4B;AAClC,IAAM,mBAAmB;AA6GzB,SAAS,mBACd,kBACA;AACA,QAAM,QAAQ,uBAAwC;AAEtD,QAAM,iBAAiB,cAErB,IAAI;AAEN,QAAM,qBAAqB,cAEjB,IAAI;AAEd,WAAS,WACP,SAC+B;AAC/B,UAAM,UAAU,QAAQ,SAAS;AACjC,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,WAAS,qBAAqB;AAAA,IAC5B;AAAA,IACA;AAAA,EACF,GAEI;AACF,UAAM,UAAU,QAAQ,MAAM;AAC5B,aAAO,8BAA8B,KAAK,IAAI;AAAA,QAC5C,UAAU,MAAM;AAAA,QAChB,UAAU,MAAM;AAAA,MAClB,CAAC;AAAA,IACH,GAAG,CAAC,KAAK,EAAE,CAAC;AAEZ,UAAM,UAAUE,OAAM,YAAY,YAAY;AAC5C,YAAM,UAAU,QACb,wBAAwB,EACxB,OAAO,CAAC,CAAC,GAAG,MAAM,QAAQ,kBAAkB,GAAG,IAAI,CAAC,EACpD,IAAI,CAAC,CAAC,GAAGC,QAAO,MAAMA,SAAQ,WAAW,CAAC;AAE7C,YAAM,YAAY,MAAM,QAAQ;AAAA,QAC9B,QAAQ,IAAI,OAAO,WAAW;AAC5B,iBAAO,MAAM,KAAK,WAAW,MAAM;AAAA,QACrC,CAAC;AAAA,MACH;AAEA,YAAM,UAAU,MAAM;AAAA,QACpB,IAAI,IAAI,UAAU,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,OAAO,IAAI,MAAM,CAAC,CAAC,EAAE,OAAO;AAAA,MACxE;AAEA,aAAO;AAAA,IACT,GAAG,CAAC,MAAM,OAAO,CAAC;AAElB,UAAM,kBAAkB,mBAAmB,SAAS,OAAO;AAE3D,UAAM,SAASC;AAAA,MACb,KAAK,OAAO,OAAO;AAAA,MACnB,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAEA,UAAM,WAAW,YAAY;AAC7B,UAAM,oBAAoB,qBAAqB;AAE/C,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA,WAAW;AAAA,IACb;AAKA,IAAAC,WAAU,MAAM;AACd,UAAI;AAEJ,eAAS,uBAAuB;AAC9B,YAAI,oBAAoB;AAAG;AAE3B,8BAAsB,OAAO,WAAW,MAAM;AAE5C,cACE,YACA,qBACA,CAAC,QAAQ,SAAS,KAClB,QAAQ,uBAAuB,IAAI,GACnC;AAEA,iBAAK,gBAAgB,EAAE,cAAc,KAAK,CAAC,EAAE;AAAA,cAC3C;AAAA,YACF;AACA;AAAA,UACF;AAEA,+BAAqB;AAAA,QACvB,GAAG,eAAe;AAAA,MACpB;AAGA,2BAAqB;AAErB,aAAO,MAAM;AACX,eAAO,aAAa,mBAAmB;AAAA,MACzC;AAAA,IACF,GAAG;AAAA,MACD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAMD,IAAAA,WAAU,MAAM;AACd,eAAS,iBAAiB;AACxB,YAAI,mBAAmB;AACrB,eAAK,gBAAgB,EAAE,cAAc,KAAK,CAAC;AAAA,QAC7C;AAAA,MACF;AAEA,aAAO,iBAAiB,UAAU,cAAc;AAChD,aAAO,MAAM;AACX,eAAO,oBAAoB,UAAU,cAAc;AAAA,MACrD;AAAA,IACF,GAAG,CAAC,iBAAiB,iBAAiB,CAAC;AAKvC,IAAAA,WAAU,MAAM;AACd,eAAS,yBAAyB;AAChC,cAAM,YAAY,SAAS,oBAAoB;AAC/C,YAAI,aAAa,UAAU;AACzB,eAAK,gBAAgB,EAAE,cAAc,KAAK,CAAC;AAAA,QAC7C;AAAA,MACF;AAEA,eAAS,iBAAiB,oBAAoB,sBAAsB;AACpE,aAAO,MAAM;AACX,iBAAS;AAAA,UACP;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,GAAG,CAAC,iBAAiB,QAAQ,CAAC;AAE9B,IAAAA,WAAU,MAAM;AACd,YAAM,cAAc,KAAK,OAAO,SAAS,UAAU,MAAM;AACvD,aAAK,gBAAgB,EAAE,cAAc,MAAM,CAAC;AAAA,MAC9C,CAAC;AACD,aAAO,MAAM;AACX,oBAAY;AAAA,MACd;AAAA,IACF,GAAG,CAAC,MAAM,eAAe,CAAC;AAE1B,WACE,gBAAAH,OAAA,cAAC,eAAe,UAAf,EAAwB,OAAO,WAC9B,gBAAAA,OAAA,cAAC,mBAAmB,UAAnB,EAA4B,OAAO,WACjC,QACH,CACF;AAAA,EAEJ;AAEA,WAAS,iBAAiB;AACxB,UAAM,UAAU,WAAW,kBAAkB;AAC7C,QAAI,YAAY,MAAM;AACpB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AACA,WAAO;AAAA,EACT;AAKA,WAAS,iCAGP,SACA,aAGA;AACA,UAAM,MAAM,UAAU,OAAO;AAC7B,UAAM,sBAAsB,YAAY,uBAAuB,GAAG;AAElE,QAAI,CAAC,qBAAqB;AACxB,YAAM,gCACJ;AAAA,QACE;AAAA,QACA;AAAA,MACF;AACF,kBAAY,uBAAuB,KAAK,6BAA6B;AACrE,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAKA,WAAS,oBAAoB;AAC3B,UAAM,UAAU,WAAW,cAAc;AACzC,QAAI,YAAY,MAAM;AACpB,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE;AACA,WAAO;AAAA,EACT;AAEA,WAAS,WACP,MACA,UAA8C,EAAE,OAAO,EAAE,UAAU,CAAC,EAAE,EAAE,GACzC;AAC/B,UAAM,MAAM,QAAQ,MAAM,UAAU,OAAO,GAAG,CAAC,OAAO,CAAC;AACvD,UAAM,UAAU,eAAe;AAE/B,UAAM,gCAAgC;AAAA,MACpC;AAAA,MACA;AAAA,IACF;AAEA,UAAM,UAAUA,OAAM;AAAA,MACpB,MAAM;AACJ,eAAO,KAAK,WAAW,OAAO;AAAA,MAChC;AAAA;AAAA,MAEA,CAAC,KAAK,IAAI;AAAA,IACZ;AAEA,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,IACF;AAEA,IAAAG,WAAU,MAAM;AACd,WAAK,gBAAgB,EAAE,cAAc,KAAK,CAAC;AAAA,IAC7C,GAAG,CAAC,eAAe,CAAC;AAEpB,IAAAA,WAAU,MAAM;AACd,cAAQ,wBAAwB,GAAG;AACnC,aAAO,MAAM;AACX,gBAAQ,wBAAwB,GAAG;AAAA,MACrC;AAAA,IACF,GAAG,CAAC,SAAS,GAAG,CAAC;AAEjB,UAAM,QAAQ,YAAY,MAAM,OAAO;AAEvC,WAAO;AAAA,EACT;AAEA,WAAS,mBACP,MACA,UAA8C,EAAE,OAAO,EAAE,UAAU,CAAC,EAAE,EAAE,GAClC;AACtC,UAAM,MAAM,QAAQ,MAAM,UAAU,OAAO,GAAG,CAAC,OAAO,CAAC;AACvD,UAAM,UAAU,eAAe;AAE/B,UAAM,gCAAgC;AAAA,MACpC;AAAA,MACA;AAAA,IACF;AAEA,UAAM,UAAUH,OAAM;AAAA,MACpB,MAAM;AACJ,eAAO,KAAK,WAAW,OAAO;AAAA,MAChC;AAAA;AAAA,MAEA,CAAC,KAAK,IAAI;AAAA,IACZ;AAEA,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,IACF;AAEA,IAAAG,WAAU,MAAM;AACd,WAAK,gBAAgB,EAAE,cAAc,KAAK,CAAC;AAAA,IAC7C,GAAG,CAAC,eAAe,CAAC;AAEpB,IAAAA,WAAU,MAAM;AACd,cAAQ,wBAAwB,GAAG;AACnC,aAAO,MAAM;AACX,gBAAQ,wBAAwB,GAAG;AAAA,MACrC;AAAA,IACF,GAAG,CAAC,SAAS,GAAG,CAAC;AAEjB,UAAM,QAAQ,YAAY,MAAM,OAAO;AAEvC,QAAI,MAAM,OAAO;AACf,YAAM,MAAM;AAAA,IACd;AAEA,QAAI,MAAM,aAAa,CAAC,MAAM,SAAS;AACrC,YAAM,gBAAgB;AAAA,QACpB,cAAc;AAAA,MAChB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,MACL,WAAW;AAAA,MACX,SAAS,MAAM;AAAA,MACf,OAAO,MAAM;AAAA,IACf;AAAA,EACF;AAEA,WAAS,YACP,MACA,SAC+B;AAC/B,UAAM,UAAU,eAAe;AAC/B,UAAM,gCAAgC;AAAA,MACpC;AAAA,MACA;AAAA,IACF;AAEA,WAAO;AAAA,MACL,MAAM;AAAA,MACN,MAAM,MAAM,WAAW;AAAA,MACvB,MAAM,MAAM,WAAW;AAAA,MACvB,CAAC,UAAU;AACT,cAAM,YAAY,8BAA8B,aAAa;AAC7D,YAAI,WAAW;AACb,iBAAO;AAAA,YACL,WAAW;AAAA,UACb;AAAA,QACF;AAEA,cAAMC,WAAU,8BAA8B,WAAW;AACzD,cAAM,QAAQ,8BAA8B,SAAS;AAGrD,cAAM,WAAW,MAAM,OAAO,CAAC,WAAW;AACxC,cAAI,OAAO,WAAW,KAAK;AAAI,mBAAO;AAEtC,gBAAM,QAAQA,SAAQ,SAAS,CAAC;AAChC,qBAAW,OAAO,MAAM,UAAU;AAChC,gBAAI,OAAO,SAAS,GAAG,MAAM,MAAM,SAAS,GAAG,GAAG;AAChD,qBAAO;AAAA,YACT;AAAA,UACF;AACA,iBAAO;AAAA,QACT,CAAC;AAED,eAAO;AAAA,UACL,WAAW;AAAA,UACX,SAAS;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,sBACP,MACA;AACA,UAAM,UAAU,eAAe;AAE/B,UAAM,UAAU,kBAAkB;AAClC,UAAM,aAAa,mBAAmB,SAAS,OAAO;AACtD,UAAM,SAAS,UAAU,SAAS,UAAU;AAE5C,UAAM,qBAAqBC;AAAA,MACzB,CAAC,YAA8D;AAC7D,cAAM,WAAW,QAAQ;AACzB,cAAM,WACJ,cAAc,UAAU,QAAQ,WAAW,CAAC;AAC9C,cAAM,UAAU,WAAW,OAAO;AAElC,cAAM,iBAAiB,QAAQ;AAAA,UAAI,CAAC,WAClC,OAAO,OAAO,WACV;AAAA,YACE,GAAG;AAAA,YACH,UAAU;AAAA,cACR,GAAG,OAAO;AAAA,cACV,GAAG;AAAA,YACL;AAAA,UACF,IACA;AAAA,QACN;AAEA,eAAO,KAAK,mBAAmB,EAAE,UAAU,SAAS,CAAC,GAAG;AAAA,UACtD;AAAA,QACF,CAAC,EAAE,MAAM,CAAC,QAAiB;AACzB,cAAI,EAAE,eAAe,mBAAmB;AACtC,kBAAM;AAAA,UACR;AAEA,gBAAM,QAAQ,uBAAuB,GAAG;AACxC,2BAAiB;AAAA,YACf,IAAI,wBAAwB,OAAO;AAAA,cACjC,QAAQ,KAAK;AAAA,cACb;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,CAAC,MAAM,QAAQ,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,gBACP,MACA;AACA,UAAM,UAAU,eAAe;AAE/B,UAAM,UAAU,kBAAkB;AAClC,UAAM,aAAa,mBAAmB,SAAS,OAAO;AACtD,UAAM,SAAS,UAAU,SAAS,UAAU;AAE5C,UAAM,eAAeA;AAAA,MACnB,CACE,YACgC;AAChC,cAAM,OAAO,QAAQ;AACrB,cAAM,WACJ,cAAc,UAAU,QAAQ,WAAY,CAAC;AAC/C,cAAM,UAAU,WAAW,OAAO;AAElC,cAAM,WAAW,eAAe;AAChC,cAAM,YAAY,gBAAgB;AAClC,cAAM,MAAM,oBAAI,KAAK;AAErB,cAAM,aAA0B;AAAA,UAC9B,IAAI;AAAA,UACJ;AAAA,UACA,QAAQ,KAAK;AAAA,UACb,WAAW;AAAA,UACX,MAAM;AAAA,UACN,QAAQ,iBAAiB,IAAI;AAAA,UAC7B;AAAA,UACA,WAAW,CAAC;AAAA,QACd;AACA,cAAM,YAAY;AAAA,UAChB,IAAI;AAAA,UACJ,MAAM;AAAA,UACN,WAAW;AAAA,UACX,QAAQ,KAAK;AAAA,UACb;AAAA,UACA,UAAU,CAAC,UAAU;AAAA,QACvB;AAEA,eAAO,KAAK,aAAa,EAAE,UAAU,WAAW,MAAM,SAAS,CAAC,GAAG;AAAA,UACjE,gBAAgB,CAAC,GAAG,SAAS,SAAS;AAAA,QACxC,CAAC,EAAE,MAAM,CAAC,QAAiB;AACzB,cAAI,EAAE,eAAe,mBAAmB;AACtC,kBAAM;AAAA,UACR;AAEA,gBAAM,QAAQ,uBAAuB,GAAG;AACxC,2BAAiB;AAAA,YACf,IAAI,kBAAkB,OAAO;AAAA,cAC3B,QAAQ,KAAK;AAAA,cACb;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAED,eAAO;AAAA,MACT;AAAA,MACA,CAAC,MAAM,QAAQ,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,iBACP,MACgD;AAChD,UAAM,UAAU,eAAe;AAE/B,UAAM,UAAU,kBAAkB;AAClC,UAAM,aAAa,mBAAmB,SAAS,OAAO;AACtD,UAAM,SAAS,UAAU,SAAS,UAAU;AAE5C,UAAM,gBAAgBA;AAAA,MACpB,CAAC,EAAE,UAAU,KAAK,MAAyC;AACzD,cAAM,UAAU,WAAW,OAAO;AAElC,cAAM,YAAY,gBAAgB;AAClC,cAAM,MAAM,oBAAI,KAAK;AAErB,cAAM,UAAuB;AAAA,UAC3B,IAAI;AAAA,UACJ;AAAA,UACA,QAAQ,KAAK;AAAA,UACb,MAAM;AAAA,UACN,WAAW;AAAA,UACX,QAAQ,iBAAiB,IAAI;AAAA,UAC7B;AAAA,UACA,WAAW,CAAC;AAAA,QACd;AAEA,cAAM,iBAAiB,QAAQ;AAAA,UAAI,CAAC,WAClC,OAAO,OAAO,WACV;AAAA,YACE,GAAG;AAAA,YACH,UAAU,CAAC,GAAG,OAAO,UAAU,OAAO;AAAA,UACxC,IACA;AAAA,QACN;AAEA,eAAO,KAAK,cAAc,EAAE,UAAU,WAAW,KAAK,CAAC,GAAG;AAAA,UACxD;AAAA,QACF,CAAC,EAAE,MAAM,CAAC,QAAiB;AACzB,cAAI,EAAE,eAAe,mBAAmB;AACtC,kBAAM;AAAA,UACR;AAEA,gBAAM,QAAQ,uBAAuB,GAAG;AACxC,2BAAiB;AAAA,YACf,IAAI,mBAAmB,OAAO;AAAA,cAC5B,QAAQ,KAAK;AAAA,cACb;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AACD,eAAO;AAAA,MACT;AAAA,MACA,CAAC,MAAM,QAAQ,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,eACP,MACA;AACA,UAAM,UAAU,eAAe;AAE/B,UAAM,UAAU,kBAAkB;AAClC,UAAM,aAAa,mBAAmB,SAAS,OAAO;AACtD,UAAM,SAAS,UAAU,SAAS,UAAU;AAE5C,UAAM,cAAcA;AAAA,MAClB,CAAC,EAAE,UAAU,WAAW,KAAK,MAAgC;AAC3D,cAAM,UAAU,WAAW,OAAO;AAClC,cAAM,MAAM,oBAAI,KAAK;AAErB,cAAM,iBAAiB,QAAQ;AAAA,UAAI,CAAC,WAClC,OAAO,OAAO,WACV;AAAA,YACE,GAAG;AAAA,YACH,UAAU,OAAO,SAAS;AAAA,cAAI,CAAC,YAC7B,QAAQ,OAAO,YACV;AAAA,gBACC,GAAG;AAAA,gBACH,UAAU;AAAA,gBACV;AAAA,cACF,IACA;AAAA,YACN;AAAA,UACF,IACA;AAAA,QACN;AAEA,eAAO,KAAK,YAAY,EAAE,UAAU,WAAW,KAAK,CAAC,GAAG;AAAA,UACtD;AAAA,QACF,CAAC,EAAE,MAAM,CAAC,QAAiB;AACzB,cAAI,EAAE,eAAe,mBAAmB;AACtC,kBAAM;AAAA,UACR;AAEA,gBAAM,QAAQ,uBAAuB,GAAG;AACxC,2BAAiB;AAAA,YACf,IAAI,iBAAiB,OAAO;AAAA,cAC1B,QAAQ,KAAK;AAAA,cACb;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,CAAC,MAAM,QAAQ,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,iBACP,MACA;AACA,UAAM,UAAU,eAAe;AAE/B,UAAM,UAAU,kBAAkB;AAClC,UAAM,aAAa,mBAAmB,SAAS,OAAO;AACtD,UAAM,SAAS,UAAU,SAAS,UAAU;AAE5C,UAAM,gBAAgBA;AAAA,MACpB,CAAC,EAAE,UAAU,UAAU,MAAkC;AACvD,cAAM,UAAU,WAAW,OAAO;AAClC,cAAM,MAAM,oBAAI,KAAK;AAErB,cAAM,aAA4C,CAAC;AAEnD,mBAAW,UAAU,SAAS;AAC5B,cAAI,OAAO,OAAO,UAAU;AAC1B,kBAAM,YAAyC;AAAA,cAC7C,GAAG;AAAA,cACH,UAAU,OAAO,SAAS;AAAA,gBAAI,CAAC,YAC7B,QAAQ,OAAO,YACX;AAAA,kBACE,GAAG;AAAA,kBACH,WAAW;AAAA,kBACX,MAAM;AAAA,gBACR,IACA;AAAA,cACN;AAAA,YACF;AAEA,gBACE,UAAU,SAAS;AAAA,cACjB,CAAC,YAAY,QAAQ,cAAc;AAAA,YACrC,GACA;AACA,yBAAW,KAAK,SAAS;AAAA,YAC3B;AAAA,UACF,OAAO;AACL,uBAAW,KAAK,MAAM;AAAA,UACxB;AAAA,QACF;AAEA,eAAO,KAAK,cAAc,EAAE,UAAU,UAAU,CAAC,GAAG;AAAA,UAClD,gBAAgB;AAAA,QAClB,CAAC,EAAE,MAAM,CAAC,QAAiB;AACzB,cAAI,EAAE,eAAe,mBAAmB;AACtC,kBAAM;AAAA,UACR;AAEA,gBAAM,QAAQ,uBAAuB,GAAG;AACxC,2BAAiB;AAAA,YACf,IAAI,mBAAmB,OAAO;AAAA,cAC5B,QAAQ,KAAK;AAAA,cACb;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,CAAC,MAAM,QAAQ,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,eACP,MACA;AACA,UAAM,UAAU,eAAe;AAE/B,UAAM,UAAU,kBAAkB;AAClC,UAAM,aAAa,mBAAmB,SAAS,OAAO;AACtD,UAAM,SAAS,UAAU,SAAS,UAAU;AAE5C,UAAM,gBAAgBA;AAAA,MACpB,CAAC,EAAE,UAAU,WAAW,MAAM,MAAoC;AAChE,cAAM,UAAU,WAAW,OAAO;AAClC,cAAM,MAAM,oBAAI,KAAK;AACrB,cAAM,SAAS,iBAAiB,IAAI;AAEpC,cAAM,iBAAiB,QAAQ;AAAA,UAAI,CAAC,WAClC,OAAO,OAAO,WACV;AAAA,YACE,GAAG;AAAA,YACH,UAAU,OAAO,SAAS,IAAI,CAAC,YAAY;AACzC,kBAAI,QAAQ,OAAO,WAAW;AAC5B,uBAAO;AAAA,cACT;AAEA,kBAAI;AAEJ,kBACE,QAAQ,UAAU;AAAA,gBAChB,CAAC,aAAa,SAAS,UAAU;AAAA,cACnC,GACA;AACA,4BAAY,QAAQ,UAAU;AAAA,kBAAI,CAAC,aACjC,SAAS,UAAU,QACf;AAAA,oBACE,GAAG;AAAA,oBACH,OAAO,CAAC,GAAG,SAAS,OAAO,EAAE,IAAI,OAAO,CAAC;AAAA,kBAC3C,IACA;AAAA,gBACN;AAAA,cACF,OAAO;AACL,4BAAY;AAAA,kBACV,GAAG,QAAQ;AAAA,kBACX;AAAA,oBACE;AAAA,oBACA,WAAW;AAAA,oBACX,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC;AAAA,kBACxB;AAAA,gBACF;AAAA,cACF;AAEA,qBAAO;AAAA,gBACL,GAAG;AAAA,gBACH;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH,IACA;AAAA,QACN;AAEA,eAAO,KAAK,YAAY,EAAE,UAAU,WAAW,MAAM,CAAC,GAAG;AAAA,UACvD;AAAA,QACF,CAAC,EAAE,MAAM,CAAC,QAAiB;AACzB,cAAI,EAAE,eAAe,mBAAmB;AACtC,kBAAM;AAAA,UACR;AAEA,gBAAM,QAAQ,uBAAuB,GAAG;AACxC,2BAAiB;AAAA,YACf,IAAI,iBAAiB,OAAO;AAAA,cAC1B,QAAQ,KAAK;AAAA,cACb;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,CAAC,MAAM,QAAQ,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,kBACP,MACA;AACA,UAAM,UAAU,eAAe;AAE/B,UAAM,UAAU,kBAAkB;AAClC,UAAM,aAAa,mBAAmB,SAAS,OAAO;AACtD,UAAM,SAAS,UAAU,SAAS,UAAU;AAE5C,UAAM,gBAAgBA;AAAA,MACpB,CAAC,EAAE,UAAU,WAAW,MAAM,MAAoC;AAChE,cAAM,UAAU,WAAW,OAAO;AAClC,cAAM,SAAS,iBAAiB,IAAI;AAEpC,cAAM,iBAAiB,QAAQ;AAAA,UAAI,CAAC,WAClC,OAAO,OAAO,WACV;AAAA,YACE,GAAG;AAAA,YACH,UAAU,OAAO,SAAS,IAAI,CAAC,YAAY;AACzC,kBAAI,QAAQ,OAAO,WAAW;AAC5B,uBAAO;AAAA,cACT;AAEA,oBAAM,gBAAgB,QAAQ,UAAU;AAAA,gBACtC,CAAC,aAAa,SAAS,UAAU;AAAA,cACnC;AACA,kBAAI,YAA+B,QAAQ;AAE3C,kBACE,iBAAiB,KACjB,QAAQ,UAAU,aAAa,EAAE,MAAM;AAAA,gBACrC,CAAC,SAAS,KAAK,OAAO;AAAA,cACxB,GACA;AACA,oBAAI,QAAQ,UAAU,aAAa,EAAE,MAAM,UAAU,GAAG;AACtD,8BAAY,CAAC,GAAG,QAAQ,SAAS;AACjC,4BAAU,OAAO,eAAe,CAAC;AAAA,gBACnC,OAAO;AACL,4BAAU,aAAa,IAAI;AAAA,oBACzB,GAAG,UAAU,aAAa;AAAA,oBAC1B,OAAO,UAAU,aAAa,EAAE,MAAM;AAAA,sBACpC,CAAC,SAAS,KAAK,OAAO;AAAA,oBACxB;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAEA,qBAAO;AAAA,gBACL,GAAG;AAAA,gBACH;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH,IACA;AAAA,QACN;AAEA,eAAO,KAAK,eAAe,EAAE,UAAU,WAAW,MAAM,CAAC,GAAG;AAAA,UAC1D;AAAA,QACF,CAAC,EAAE,MAAM,CAAC,QAAiB;AACzB,cAAI,EAAE,eAAe,mBAAmB;AACtC,kBAAM;AAAA,UACR;AAEA,gBAAM,QAAQ,uBAAuB,GAAG;AACxC,2BAAiB;AAAA,YACf,IAAI,oBAAoB,OAAO;AAAA,cAC7B,QAAQ,KAAK;AAAA,cACb;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,CAAC,MAAM,QAAQ,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,mBAAmB,QAAgB;AAC1C,SAAO,GAAG,MAAM,IAAI,OAAO,CAAC;AAC9B;AAEO,SAAS,iBAAiB;AAC/B,SAAO,mBAAmB,gBAAgB;AAC5C;AAEO,SAAS,kBAAkB;AAChC,SAAO,mBAAmB,iBAAiB;AAC7C;AAEA,SAAS,iBACP,MACQ;AACR,QAAM,OAAO,KAAK,QAAQ;AAC1B,MAAI,SAAS,QAAQ,KAAK,OAAO,QAAW;AAC1C,WAAO;AAAA,EACT,OAAO;AACL,WAAO,KAAK;AAAA,EACd;AACF;AAEA,SAAS,uBAAuB,KAA8B;AAC5D,QAAM,UAAU,8BAA8B,IAAI,MAAM,KAAK,IAAI,OAAO;AAGxE,MAAI,IAAI,SAAS,UAAU,aAAa;AACtC,UAAM,kBAAkB,CAAC,SAAS,IAAI,QAAQ,YAAY,IAAI,QAAQ,IAAI,EACvE,OAAO,OAAO,EACd,KAAK,IAAI;AAEZ,YAAQ,MAAM,eAAe;AAAA,EAC/B;AAEA,SAAO,IAAI,MAAM,OAAO;AAC1B;AAkBO,SAAS,8BAGd,QACA;AAAA,EACE;AAAA,EACA;AACF,GAIA;AACA,MAAI;AACJ,MAAI;AACJ,MAAI;AAGJ,QAAM,+BAA+B,oBAAI,IAGvC;AAGF,QAAM,0BAA0B,oBAAI,IAAoB;AAExD,SAAO;AAAA;AAAA,IAEL,WAAW;AACT,YAAM,UAAU,SAAS;AAEzB,YAAM,WAAW,QAAQ,OAAO,CAAC,WAAW,OAAO,WAAW,MAAM;AACpE,aAAO;AAAA,IACT;AAAA,IACA,SAAS,OAAsC;AAE7C,iBAAW,OAAO,6BAA6B,KAAK,GAAG;AACrD,YAAI,wBAAwB,IAAI,GAAG,MAAM,GAAG;AAC1C,uCAA6B,OAAO,GAAG;AACvC,kCAAwB,OAAO,GAAG;AAAA,QACpC;AAAA,MACF;AAGA,YAAM,SAAS,MAAM;AAAA,QACnB,CAAC,GAAG,MACF,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAAI,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ;AAAA,MACpE;AAEA,YAAM,UAAU,SAAS;AACzB,YAAM,aAAa,QAChB,OAAO,CAAC,WAAW,OAAO,WAAW,MAAM,EAC3C,OAAO,MAAM;AAEhB,eAAS,UAAU;AAAA,IACrB;AAAA;AAAA,IAGA,aAAa;AACX,aAAO;AAAA,IACT;AAAA,IACA,WAAW,OAA+D;AACxE,gBAAU;AAAA,IACZ;AAAA;AAAA,IAGA,WAAW;AACT,aAAO;AAAA,IACT;AAAA,IACA,SAAS,KAAY;AACnB,cAAQ;AAAA,IACV;AAAA;AAAA,IAGA,cAAc;AACZ,aAAO;AAAA,IACT;AAAA,IACA,YAAY,MAAoB;AAC9B,iBAAW;AAAA,IACb;AAAA,IAEA,0BAA0B;AACxB,aAAO,MAAM,KAAK,6BAA6B,QAAQ,CAAC;AAAA,IAC1D;AAAA,IAEA,uBAAuB,KAAa;AAClC,aAAO,6BAA6B,IAAI,GAAG;AAAA,IAC7C;AAAA,IAEA,uBACE,KACA,SACA;AACA,mCAA6B,IAAI,KAAK,OAAO;AAAA,IAC/C;AAAA,IAEA,yBAAyB;AACvB,aAAO,MAAM,KAAK,wBAAwB,OAAO,CAAC,EAAE;AAAA,QAClD,CAAC,KAAK,UAAU,MAAM;AAAA,QACtB;AAAA,MACF;AAAA,IACF;AAAA,IAEA,wBAAwB,KAAa;AACnC,YAAM,QAAQ,wBAAwB,IAAI,GAAG,KAAK;AAClD,8BAAwB,IAAI,KAAK,QAAQ,CAAC;AAAA,IAC5C;AAAA,IAEA,wBAAwB,KAAa;AACnC,YAAM,QAAQ,wBAAwB,IAAI,GAAG,KAAK;AAClD,8BAAwB,IAAI,KAAK,QAAQ,CAAC;AAAA,IAC5C;AAAA,IAEA,kBAAkB,KAAa;AAC7B,aAAO,wBAAwB,IAAI,GAAG,KAAK;AAAA,IAC7C;AAAA,EACF;AACF;AA8EA,SAAS,yBAA+D;AACtE,MAAI,UAAyC,CAAC;AAG9C,QAAM,qBAAqB,gBAA+C;AAE1E,SAAO;AAAA,IACL,aAAa;AACX,aAAO;AAAA,IACT;AAAA,IACA,WAAW,OAAsC;AAC/C,gBAAU;AAEV,yBAAmB,OAAO,OAAO;AAAA,IACnC;AAAA,IAEA,UAAU,UAA0D;AAClE,aAAO,mBAAmB,UAAU,QAAQ;AAAA,IAC9C;AAAA,EACF;AACF;AAEA,SAAS,oCAGP,SACA,SACgD;AAChD,MAAI,YAAqB;AACzB,MAAI;AACJ,MAAI;AAEJ,SAAO;AAAA;AAAA,IAEL,WAAW;AACT,aAAO;AAAA,IACT;AAAA,IACA,SAAS,OAAsC;AAC7C,YAAM,QAAQ,IAAI;AAAA,SACf,QAAQ,SAAS,KAAK,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,IAAI,MAAM,CAAC;AAAA,MAChE;AAEA,iBAAW,UAAU,OAAO;AAC1B,cAAM,IAAI,OAAO,IAAI,MAAM;AAAA,MAC7B;AACA,cAAQ,SAAS,MAAM,KAAK,MAAM,OAAO,CAAC,CAAC;AAE3C,kBAAY;AAAA,IACd;AAAA;AAAA,IAGA,aAAa;AACX,aAAO;AAAA,IACT;AAAA,IACA,WAAW,OAA+D;AACxE,gBAAU;AAAA,IACZ;AAAA;AAAA,IAGA,WAAW;AACT,aAAO;AAAA,IACT;AAAA,IACA,SAAS,KAAY;AACnB,cAAQ;AACR,kBAAY;AACZ,YAAM,QAAQ,QAAQ,SAAS;AAC/B,cAAQ,SAAS,KAAK;AAAA,IACxB;AAAA;AAAA,IAGA,cAAc;AAEZ,aAAO;AAAA,IACT;AAAA,IACA,YAAY,GAAiB;AAE3B;AAAA,IACF;AAAA,IAEA,aAAa;AACX,aAAO;AAAA,IACT;AAAA,IAEA,eAAe;AACb,aAAO;AAAA,IACT;AAAA,IAEA,aAAa,OAAgB;AAC3B,kBAAY;AAAA,IACd;AAAA,EACF;AACF;AASA,SAAS,mBACP,iBACA,mBACA,iBACoB;AAEpB,MAAI,CAAC,mBAAmB,CAAC;AAAmB;AAG5C,MAAI;AAAiB,WAAO;AAG5B,SAAO;AACT;;;AK/0CA,SAAS,aAAAC,YAAW,UAAAC,SAAQ,YAAAC,iBAAgB;AAE5C,IAAM,gBAAgB;AAEf,SAAS,YACd,OACA,QAAwB,eACrB;AACH,QAAM,UAAUD,QAAe;AAC/B,QAAM,CAAC,gBAAgB,iBAAiB,IAAIC,UAAY,KAAK;AAE7D,EAAAF,WAAU,MAAM;AACd,QAAI,UAAU,OAAO;AACnB;AAAA,IACF;AAEA,QAAI,QAAQ,YAAY,QAAW;AACjC,wBAAkB,KAAK;AAAA,IACzB;AAEA,YAAQ,UAAU,OAAO,WAAW,MAAM;AACxC,wBAAkB,KAAK;AACvB,cAAQ,UAAU;AAAA,IACpB,GAAG,KAAK;AAER,WAAO,MAAM;AACX,aAAO,aAAa,QAAQ,OAAO;AAAA,IACrC;AAAA,EACF,GAAG,CAAC,OAAO,KAAK,CAAC;AAEjB,SAAO;AACT;;;ACzBA,SAAS,eAAAG,cAAa,aAAAC,YAAW,WAAAC,UAAS,UAAAC,eAAc;AACxD,SAAS,wBAAAC,6BAA4B;;;ACPrC,SAAS,YAAAC,iBAAgB;AAQlB,SAAS,WAAc,OAAa;AACzC,SAAOA,UAAS,KAAK,EAAE,CAAC;AAC1B;;;ADCA,IAAM,sBAAyC;AAAA,EAC7C,WAAW;AAAA,EACX,MAAM;AAAA,EACN,OAAO;AACT;AAsCA,IAAM,OAAO,MAAM;AAAC;AAEb,SAAS,cACd,OACA,KACA,SACgC;AAChC,QAAM,gBAAgB,WAAW,OAAO;AACxC,QAAM,YAAYC,SAAQ,MAAM;AAC9B,QAAI,QAAQ,QAAQ,CAAC,OAAO;AAC1B,aAAO;AAAA,IACT;AAEA,UAAMC,aAAY,MAAM,OAAO,GAAG;AAClC,SAAKA,WAAU,IAAI;AAEnB,WAAOA;AAAA,EACT,GAAG,CAAC,OAAO,GAAG,CAAC;AAEf,QAAMC,aAAYC;AAAA,IAChB,CAAC,aAAyB,WAAW,UAAU,QAAQ,KAAK;AAAA,IAC5D,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,WAAWA;AAAA,IACf,MAAM,WAAW,SAAS,KAAK;AAAA,IAC/B,CAAC,SAAS;AAAA,EACZ;AAEA,QAAM,aAAaA,aAAY,MAAM,WAAW,WAAW,GAAG,CAAC,SAAS,CAAC;AAEzE,QAAM,QAAQC,sBAAqBF,YAAW,UAAU,QAAQ;AAChE,QAAM,eAAeG,QAAwB;AAC7C,MAAI,OAAO,MAAM;AAEjB,EAAAC,WAAU,MAAM;AACd,iBAAa,UAAU,EAAE,KAAK,MAAM,MAAM,KAAK;AAAA,EACjD,GAAG,CAAC,KAAK,MAAM,IAAI,CAAC;AAEpB,MAAI,CAAC,WAAW;AACd,WAAO;AAAA,MACL,WAAW;AAAA,MACX,MAAM;AAAA,MACN,OAAO;AAAA,MACP;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,MAAI,eAAe,UAAU;AAC3B,UAAM,QAAQ,SAAS,EAAE;AAEzB,QAAI,OAAO;AACT,YAAM;AAAA,IACR,WAAW,SAAS,EAAE,WAAW;AAC/B,YAAM,IAAI,QAAc,CAAC,YAAY;AACnC,kBAAU,cAAc,CAACC,WAAU;AACjC,cAAI,CAACA,OAAM,WAAW;AACpB,oBAAQ;AAAA,UACV;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACF;AAEA,MACE,MAAM,aACN,eAAe,gCACf,OAAO,MAAM,SAAS,eACtB,aAAa,SAAS,QAAQ,OAC9B,OAAO,aAAa,SAAS,SAAS,aACtC;AACA,WAAO,aAAa,QAAQ;AAAA,EAC9B;AAEA,SAAO;AAAA,IACL,WAAW,MAAM;AAAA,IACjB;AAAA,IACA,OAAO,MAAM;AAAA,IACb;AAAA,IACA;AAAA,EACF;AACF;;;AEvIA,SAAS,aAAAC,YAAW,UAAAC,eAAc;AAU3B,SAAS,UAAa,OAAmC;AAC9D,QAAM,MAAMA,QAAO,KAAK;AACxB,EAAAD,WAAU,MAAM;AACd,QAAI,UAAU;AAAA,EAChB,GAAG,CAAC,KAAK,CAAC;AACV,SAAO;AACT;;;AChBA,SAAS,kBAAkB;AAepB,SAAS,cAA0B;AACxC,QAAM,CAAC,EAAE,MAAM,IAAI;AAAA;AAAA;AAAA;AAAA,IAIjB,CAAC,MAAsB,IAAI;AAAA,IAC3B;AAAA,EACF;AACA,SAAO;AACT;;;AVqCA,IAAME,QAAO,MAAM;AAAC;AACpB,IAAM,WAA2B,CAAC,MAAM;AAExC,IAAM,kCAAkC,CACtC,cACA,WAEA,sCAAiC,YAAY;AAAA;AAAA;AAAA;AAAA,uBAIxB,KAAK;AAAA,EACtB;AACF,CAAC;AAAA;AAAA;AAAA;AAAA;AAML,IAAM,sCACJ;AAEK,SAASC,sBACd,GACA,IACA,KACU;AACV,SAAOC,kCAAiC,GAAG,IAAI,KAAK,QAAQ;AAC9D;AAEA,IAAM,oBAAoB,OAAO,OAAO,CAAC,CAAC;AAI1C,SAAS,kBAAkB;AACzB,SAAO;AACT;AAIA,SAAS,aAAa;AACpB,SAAO;AACT;AAEA,SAAS,oBAMP,MACiD;AACjD,QAAM,SACJ;AAEF,SAAO;AAAA,IACL,IAAI,UAAU;AACZ,YAAM,cAAc,KAAK,mBAAmB;AAC5C,UAAI,gBAAgB,MAAM;AACxB,cAAM,IAAI,MAAM,MAAM;AAAA,MACxB;AACA,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,OAAO;AACT,YAAM,OAAO,KAAK,QAAQ;AAC1B,UAAI,SAAS,MAAM;AACjB,cAAM,IAAI,MAAM,MAAM;AAAA,MACxB;AACA,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,SAAS;AACX,YAAM,SAAS,KAAK,UAAU;AAC9B,UAAI,KAAK,QAAQ,MAAM,MAAM;AAC3B,cAAM,IAAI,MAAM,MAAM;AAAA,MACxB;AACA,aAAO;AAAA,IACT;AAAA,IAEA,eAAe,KAAK;AAAA,EACtB;AACF;AA4BA,IAAI,4BAA4B;AAEhC,SAAS,qBAAqB,YAA2C;AACvE,MACE,CAAC,6BACD,CAAC,cACD,QAAQ,IAAI,aAAa,cACzB;AACA,YAAQ;AAAA,MACN;AAAA,IACF;AACA,gCAA4B;AAAA,EAC9B;AACF;AAEA,IAAM,gBAAsB,qBAMlB,IAAI;AAOP,SAAS,uBAAuB;AACrC,QAAM,SAAe,kBAAW,aAAa;AAC7C,MAAI,WAAW,MAAM;AACnB,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAChE;AACA,SAAO;AACT;AAEO,SAAS,kBAOd,QACA,SAOA;AAIA,QAAM,cAAoB,qBAA4B,IAAI;AAE1D,QAAM,2BACJC,iBAAgD;AAElD,QAAM,EAAE,sBAAsB,GAAG,aAAa,IAC5C,mBAAoC,wBAAwB;AAqB9D,WAAS,kBAAkB,OAA+C;AACxE,UAAM,CAAC,KAAK,IAAU;AAAA,MACpB,MAAM,oBAAI,IAAI;AAAA,IAChB;AAKA,UAAM,kBAAwB;AAAA,MAC5B,CACE,QACAC,aACmB;AACnB,cAAM,SAAS,MAAM,IAAI,MAAM;AAC/B,YAAI;AAAQ,iBAAO;AAEnB,cAAM,KAAK,OAAO;AAAA,UAChB;AAAA,UACAA;AAAA,QACF;AAGA,cAAM,YAAY,GAAG;AACrB,WAAG,QAAQ,MAAM;AACf,oBAAU;AACV,gBAAM,OAAO,MAAM;AAAA,QACrB;AAEA,cAAM,IAAI,QAAQ,EAAE;AACpB,eAAO;AAAA,MACT;AAAA,MACA,CAAC,KAAK;AAAA,IACR;AAEA,WAAO,qCAAC,qBAAmB,GAAG,OAAO,iBAAkC;AAAA,EACzE;AAEA,WAAS,kBACP,OAMA;AACA,UAAM,EAAE,IAAI,QAAQ,gBAAgB,IAAI;AAExC,QAAI,QAAQ,IAAI,aAAa,cAAc;AACzC,UAAI,CAAC,QAAQ;AACX,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,UAAI,OAAO,WAAW,UAAU;AAC9B,cAAM,IAAI,MAAM,8CAA8C;AAAA,MAChE;AAEA,YAAM,oBAAoB,SAAe,cAAO,KAAK;AACrD,YAAM,kBAAkB,oBAAoB;AAC5C;AAAA,QACE,mBAAmB,MAAM,4BAA4B;AAAA,QACrD,gCAAgC,mBAAmB,MAAM;AAAA,MAC3D;AACA;AAAA,QACE,CAAC,mBAAmB,MAAM,4BAA4B;AAAA,QACtD;AAAA,MACF;AAAA,IACF;AAIA,UAAM,cAAc,WAAW;AAAA,MAC7B,iBAAiB,MAAM;AAAA,MACvB,gBAAgB,MAAM;AAAA,MACtB,yBAAyB,MAAM;AAAA,MAC/B,aACE,MAAM,eACN,MAAM,0BACN,OAAO,WAAW;AAAA,IACtB,CAAC;AAED,UAAM,CAAC,EAAE,KAAK,GAAG,gBAAgB,IAAU;AAAA,MAAS,MAClD,gBAAgB,QAAQ;AAAA,QACtB,GAAG;AAAA,QACH,aAAa;AAAA;AAAA,MACf,CAAC;AAAA,IACH;AAEA,IAAM,iBAAU,MAAM;AACpB,YAAM,OAAO,gBAAgB,QAAQ,WAAW;AAEhD,uBAAiB,IAAI;AACrB,YAAM,EAAE,MAAAC,OAAM,MAAM,IAAI;AAQxB,UAAI,YAAY,aAAa;AAC3B,QAAAA,MAAK,QAAQ;AAAA,MACf;AAEA,aAAO,MAAM;AACX,cAAM;AAAA,MACR;AAAA,IACF,GAAG,CAAC,QAAQ,aAAa,eAAe,CAAC;AAEzC,WACE,qCAAC,YAAY,UAAZ,EAAqB,OAAO,QAC3B,qCAAC,wBAAqB,QACpB;AAAA,MAAC,cAAc;AAAA,MAAd;AAAA,QACC,OACE;AAAA;AAAA,MASD,MAAM;AAAA,IACT,CACF,CACF;AAAA,EAEJ;AAEA,WAAS,qBACP,QACU;AACV,WAAO,OAAO,IAAI,CAAC,SAAS,KAAK,YAAY;AAAA,EAC/C;AAEA,WAAS,UAAiB;AACxB,UAAM,OAAa,kBAAW,WAAW;AACzC,QAAI,SAAS,MAAM;AACjB,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AACA,WAAO;AAAA,EACT;AAEA,WAAS,YAAoB;AAC3B,UAAM,OAAO,QAAQ;AACrB,UAAMC,aAAY,KAAK,OAAO,OAAO;AACrC,UAAMC,eAAc,KAAK;AACzB,UAAM,oBAAoB,KAAK;AAC/B,WAAON,sBAAqBK,YAAWC,cAAa,iBAAiB;AAAA,EACvE;AAEA,WAAS,gBAGP;AACA,UAAM,OAAO,QAAQ;AACrB,UAAMD,aAAY,KAAK,OAAO,WAAW;AACzC,UAAMC,eAAc,KAAK;AACzB,UAAM,WAAWN,sBAAqBK,YAAWC,cAAaA,YAAW;AACzE,UAAM,cAAc,KAAK;AACzB,WAAO,CAAC,UAAU,WAAW;AAAA,EAC/B;AAEA,WAAS,sBAGC;AACR,WAAO,QAAQ,EAAE;AAAA,EACnB;AAOA,WAAS,UACP,UACA,SAC2C;AAC3C,UAAM,OAAO,QAAQ;AACrB,UAAMD,aAAY,KAAK,OAAO,OAAO;AACrC,UAAMC,eAAc,KAAK;AACzB,UAAM,oBAAoB;AAC1B,WAAOL;AAAA,MACLI;AAAA,MACAC;AAAA,MACA;AAAA,MACA,YACG;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,WAAS,yBAA4C;AACnD,WAAO,UAAU,sBAAsB,OAAO;AAAA,EAChD;AAEA,WAAS,gBACP,cACA,aACyD;AACzD,UAAM,kBAAwB;AAAA,MAC5B,CAAC,WACC,OAAO;AAAA,QACL,CAAC,UAAU,CAAC,MAAM,cAAc,aAAa,KAAK,CAAC;AAAA,MACrD;AAAA,MACF,CAAC,YAAY;AAAA,IACf;AAEA,UAAM,iBAAuB;AAAA,MAC3B,CACE,GACA,MACY;AACZ,cAAM,KAAK,eAAe,OAAO;AACjC,eACE,EAAE,WAAW,EAAE,UACf,EAAE,MAAM,CAAC,QAAQ,UAAU;AACzB,gBAAM,SAAS,EAAE,KAAK;AACtB,iBAAO,OAAO,CAAC,MAAM,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,QAC3D,CAAC;AAAA,MAEL;AAAA,MACA,CAAC,WAAW;AAAA,IACd;AAEA,WAAO,UAAU,iBAAiB,cAAc;AAAA,EAClD;AAEA,QAAM,YAAY,OAAO;AAIzB,WAAS,SACP,cACA,UACA,SACG;AACH,UAAM,kBAAwB;AAAA,MAC5B,CAAC,WAAkD;AAEjD,cAAMC,SAAQ,OAAO;AAAA,UACnB,CAACA,WAAUA,OAAM,iBAAiB;AAAA,QACpC;AACA,eAAOA,WAAU,SAAY,SAASA,MAAK,IAAI;AAAA,MACjD;AAAA,MACA,CAAC,cAAc,QAAQ;AAAA,IACzB;AAEA,UAAM,iBAAuB;AAAA,MAC3B,CAAC,MAAoB,SAAgC;AACnD,YAAI,SAAS,aAAa,SAAS,WAAW;AAC5C,iBAAO,SAAS;AAAA,QAClB;AAEA,cAAM,KAAK,WAAW,OAAO;AAC7B,eAAO,GAAG,MAAM,IAAI;AAAA,MACtB;AAAA,MACA,CAAC,OAAO;AAAA,IACV;AAEA,UAAM,QAAQ,UAAU,iBAAiB,cAAc;AACvD,QAAI,UAAU,WAAW;AACvB,YAAM,IAAI;AAAA,QACR,yCAAyC,YAAY;AAAA,MACvD;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,oBAGC;AACR,UAAM,OAAO,QAAQ;AAErB,WAAa;AAAA,MACX,CACE,OACAJ,WAA4B,EAAE,4BAA4B,MAAM,MAC7D;AACH,aAAK,eAAe,OAAOA,QAAO;AAAA,MACpC;AAAA,MACA,CAAC,IAAI;AAAA,IACP;AAAA,EACF;AAEA,WAAS,kBACP,UACA;AACA,UAAM,OAAO,QAAQ;AACrB,UAAM,gBAAgB,UAAU,QAAQ;AAExC,IAAM;AAAA,MACJ,MACE,KAAK,OAAO,OAAO,UAAU,CAAC,UAAU,cAAc,QAAQ,KAAK,CAAC;AAAA,MACtE,CAAC,MAAM,aAAa;AAAA,IACtB;AAAA,EACF;AAEA,WAAS,0BACP,UACM;AACN,UAAM,OAAO,QAAQ;AACrB,UAAM,gBAAgB,UAAU,QAAQ;AAExC,IAAM;AAAA,MACJ,MACE,KAAK,OAAO,eAAe;AAAA,QAAU,CAAC,UACpC,cAAc,QAAQ,KAAK;AAAA,MAC7B;AAAA,MACF,CAAC,MAAM,aAAa;AAAA,IACtB;AAAA,EACF;AAEA,WAAS,iBAAiB,UAAsC;AAC9D,UAAM,OAAO,QAAQ;AACrB,UAAM,gBAAgB,UAAU,QAAQ;AAExC,IAAM;AAAA,MACJ,MAAM,KAAK,OAAO,MAAM,UAAU,CAAC,MAAM,cAAc,QAAQ,CAAC,CAAC;AAAA,MACjE,CAAC,MAAM,aAAa;AAAA,IACtB;AAAA,EACF;AAEA,WAAS,iBACP,UACM;AACN,UAAM,OAAO,QAAQ;AACrB,UAAM,gBAAgB,UAAU,QAAQ;AAExC,IAAM,iBAAU,MAAM;AACpB,YAAM,WAAW,CACf,cACG;AACH,sBAAc,QAAQ,SAAS;AAAA,MACjC;AAEA,aAAO,KAAK,OAAO,YAAY,UAAU,QAAQ;AAAA,IACnD,GAAG,CAAC,MAAM,aAAa,CAAC;AAAA,EAC1B;AAOA,WAAS,QACP,eACA,SACuC;AAIvC,UAAM,OAAO,QAAQ;AACrB,UAAME,aAAY,KAAK,OAAO,KAAK;AACnC,UAAMC,eAA8B,KAAK;AAEzC,UAAM,WACJ,iBAAkB;AACpB,UAAM,kBAAwB;AAAA,MAC5B,CAAC,OAA6B,OAAO,OAAO,SAAS,EAAE,IAAI;AAAA,MAC3D,CAAC,QAAQ;AAAA,IACX;AAEA,UAAM,oBAAoB;AAE1B,WAAOL;AAAA,MACLI;AAAA,MACAC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,WAAS,wBAAqD;AAC5D,UAAM,OAAO,QAAQ;AACrB,UAAMD,aAAY,KAAK,OAAO,eAAe;AAC7C,UAAMC,eAAc,KAAK;AACzB,UAAM,oBAAoB;AAC1B,WAAON,sBAAqBK,YAAWC,cAAa,iBAAiB;AAAA,EACvE;AAGA,WAAS,iBAAsD;AAC7D,WAAO,CAAC,sBAAsB,CAAC;AAAA,EACjC;AAEA,WAAS,aAAsB;AAC7B,WAAO,QAAQ,EAAE;AAAA,EACnB;AAEA,WAAS,UAAsB;AAC7B,WAAO,WAAW,EAAE;AAAA,EACtB;AAEA,WAAS,UAAsB;AAC7B,WAAO,WAAW,EAAE;AAAA,EACtB;AAEA,WAAS,aAAsB;AAC7B,UAAM,OAAO,QAAQ;AACrB,UAAMD,aAAY,KAAK,OAAO,QAAQ;AACtC,UAAM,UAAU,KAAK,QAAQ;AAC7B,WAAOL,sBAAqBK,YAAW,SAAS,OAAO;AAAA,EACzD;AAEA,WAAS,aAAsB;AAC7B,UAAM,OAAO,QAAQ;AACrB,UAAMA,aAAY,KAAK,OAAO,QAAQ;AACtC,UAAM,UAAU,KAAK,QAAQ;AAC7B,WAAOL,sBAAqBK,YAAW,SAAS,OAAO;AAAA,EACzD;AAEA,WAAS,WAAwC;AAC/C,WAAO,QAAQ,EAAE;AAAA,EACnB;AAEA,WAAS,aACP,KACuB;AACvB,UAAM,OAAO,QAAQ;AACrB,UAAM,aAAa,sBAAsB;AACzC,UAAM,WAAW,YAAY;AAE7B,IAAM,iBAAU,MAAM;AACpB,UAAI,eAAe,MAAM;AACvB;AAAA,MACF;AACA,YAAM,OAAO;AAEb,UAAI;AACJ,UAAI,OAAO,KAAK,IAAI,GAAG;AAEvB,eAAS,kBAAkB;AACzB,oBAAY,WAAW,IAAI,IACvB,KAAK,UAAU,MAAM,QAAQ,IAC7B;AAAA,MACN;AAEA,eAAS,eAAe;AACtB,cAAM,WAAW,KAAK,IAAI,GAAG;AAC7B,YAAI,aAAa,MAAM;AACrB,sBAAY;AACZ,iBAAO;AACP,0BAAgB;AAChB,mBAAS;AAAA,QACX;AAAA,MACF;AAEA,sBAAgB;AAChB,eAAS;AAET,YAAM,kBAAkB,KAAK,UAAU,MAAM,YAAY;AACzD,aAAO,MAAM;AACX,wBAAgB;AAChB,oBAAY;AAAA,MACd;AAAA,IACF,GAAG,CAAC,YAAY,MAAM,KAAK,QAAQ,CAAC;AAEpC,QAAI,eAAe,MAAM;AACvB,aAAO;AAAA,IACT,OAAO;AACL,aAAO,WAAW,IAAI,GAAG;AAAA,IAC3B;AAAA,EACF;AAEA,WAAS,WACP,UACA,SACU;AAIV,UAAM,OAAO,QAAQ;AACrB,UAAM,aAAa,sBAAsB;AAEzC,UAAM,kBAAwB;AAAA,MAC5B,CAACG,gBACCA,gBAAe,OAAO,SAASA,WAAU,IAAI;AAAA,MAC/C,CAAC,QAAQ;AAAA,IACX;AAEA,UAAMH,aAAkB;AAAA,MACtB,CAAC,kBACC,eAAe,OACX,KAAK,UAAU,YAAY,eAAe,EAAE,QAAQ,KAAK,CAAC,IAC1DN;AAAA,MACN,CAAC,MAAM,UAAU;AAAA,IACnB;AAEA,UAAMO,eAAoB,mBAAY,MAAgB;AACpD,UAAI,eAAe,MAAM;AACvB,eAAO;AAAA,MACT,OAAO;AACL,cAAM,OAAO;AACb,cAAM,MAAM,KAAK,YAAY;AAC7B,eAAO;AAAA,MACT;AAAA,IACF,GAAG,CAAC,UAAU,CAAC;AAEf,UAAM,oBAAoB;AAE1B,WAAOL;AAAA,MACLI;AAAA,MACAC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,WAAS,sBAA4B;AAEnC,QAAI,OAAO,WAAW,aAAa;AACjC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,+BAAqC;AAC5C,UAAM,OAAO,QAAQ;AACrB,QAAI,KAAK,mBAAmB,MAAM,MAAM;AACtC;AAAA,IACF;AAEA,wBAAoB;AAKpB,UAAM,IAAI,QAAc,CAAC,QAAQ;AAC/B,WAAK,OAAO,eAAe,cAAc,MAAM,IAAI,CAAC;AAAA,IACtD,CAAC;AAAA,EACH;AAEA,WAAS,gCAAsC;AAC7C,UAAM,OAAO,QAAQ;AACrB,QAAI,KAAK,QAAQ,MAAM,MAAM;AAC3B;AAAA,IACF;AAEA,wBAAoB;AAOpB,UAAM,IAAI,QAAc,CAAC,QAAQ;AAC/B,WAAK,OAAO,KAAK,cAAc,MAAM,IAAI,CAAC;AAC1C,WAAK,OAAO,OAAO,cAAc,MAAM,IAAI,CAAC;AAAA,IAC9C,CAAC;AAAA,EACH;AAEA,WAAS,YAKP,UAAa,MAA2C;AACxD,UAAM,OAAO,QAAQ;AACrB,WAAa;AAAA,MACX,MAAM;AACJ,eAAQ,IAAI;AAAA;AAAA,UAEV,KAAK;AAAA,YAAM;AAAA;AAAA,cAET;AAAA,gBACE,oBAAoB,IAAI;AAAA,gBAExB,GAAG;AAAA,cACL;AAAA;AAAA,UACF;AAAA;AAAA,MACJ;AAAA;AAAA,MAEA,CAAC,MAAM,GAAG,IAAI;AAAA,IAChB;AAAA,EACF;AAEA,WAAS,mBACP,UACA,SACG;AACH,iCAA6B;AAC7B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAOA,WAAS,gBACP,UACA,SACgC;AAChC,kCAA8B;AAC9B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,WAAS,kBACP,UACA,SAC2C;AAC3C,kCAA8B;AAC9B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,WAAS,iCAAoD;AAC3D,kCAA8B;AAC9B,WAAO,uBAAuB;AAAA,EAChC;AAEA,WAAS,wBACP,cACA,aACyD;AACzD,kCAA8B;AAC9B,WAAO,gBAAgB,cAAc,WAAW;AAAA,EAClD;AAEA,WAAS,iBACP,cACA,UACA,SACG;AACH,kCAA8B;AAC9B,WAAO,SAAS,cAAc,UAAU,OAAO;AAAA,EACjD;AAEA,WAAS,qBACP,KACgB;AAChB,iCAA6B;AAC7B,WAAO,aAAa,GAAG;AAAA,EACzB;AAEA,WAAS,WACPH,UAC+B;AAC/B,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,WAAW,MAAMA,QAAO;AAAA,EAC9C;AAEA,WAAS,mBAAmBA,UAA8C;AACxE,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,mBAAmB,MAAMA,QAAO;AAAA,EACtD;AAEA,WAAS,kBAAkB;AACzB,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,gBAAgB,IAAI;AAAA,EAC1C;AAEA,WAAS,wBAAwB;AAC/B,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,sBAAsB,IAAI;AAAA,EAChD;AAEA,WAAS,iBAAiB;AACxB,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,eAAe,IAAI;AAAA,EACzC;AAEA,WAAS,oBAAoB;AAC3B,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,kBAAkB,IAAI;AAAA,EAC5C;AAEA,WAAS,mBAAmE;AAC1E,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,iBAAiB,IAAI;AAAA,EAC3C;AAEA,WAAS,iBAAwD;AAC/D,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,eAAe,IAAI;AAAA,EACzC;AAEA,WAAS,mBAAmB;AAC1B,UAAM,OAAO,QAAQ;AACrB,WAAO,aAAa,iBAAiB,IAAI;AAAA,EAC3C;AAEA,QAAM,EAAE,cAAc,0BAA0B,IAAI,WAAW,CAAC;AAEhE,QAAM,aAAa,eACf,iBAAiB,OAAO,uBAA+B;AACrD,UAAM,QAAQ,MAAM;AAAA,MAClB,KAAK,MAAM,kBAAkB;AAAA,IAC/B;AAEA,WAAO,QAAQ,CAAC;AAAA,EAClB,CAAC,IACD;AAEJ,WAAS,QAAQ,QAAgB;AAC/B,UAAM,OAAO,QAAQ;AACrB,UAAM,cAAoB;AAAA,MACxB,MAAMM,WAAU,EAAE,SAAS,CAAC,MAAM,GAAG,QAAQ,KAAK,GAAG,CAAC;AAAA,MACtD,CAAC,QAAQ,KAAK,EAAE;AAAA,IAClB;AACA,UAAM,QAAQ,cAAc,YAAY,WAAW;AAEnD,IAAM,iBAAU,MAAM,qBAAqB,UAAU,GAAG,CAAC,CAAC;AAE1D,QAAI,MAAM,WAAW;AACnB,aAAO;AAAA,QACL,WAAW;AAAA,MACb;AAAA,IACF,OAAO;AACL,aAAO;AAAA,QACL,MAAM,MAAM;AAAA,QACZ,OAAO,MAAM;AAAA,QACb,WAAW;AAAA,MACb;AAAA,IACF;AAAA,EACF;AAEA,WAAS,gBAAgB,QAAgB;AACvC,UAAM,OAAO,QAAQ;AACrB,UAAM,cAAoB;AAAA,MACxB,MAAMA,WAAU,EAAE,SAAS,CAAC,MAAM,GAAG,QAAQ,KAAK,GAAG,CAAC;AAAA,MACtD,CAAC,QAAQ,KAAK,EAAE;AAAA,IAClB;AACA,UAAM,QAAQ,cAAc,YAAY,aAAa;AAAA,MACnD,UAAU;AAAA,IACZ,CAAC;AAED,IAAM,iBAAU,MAAM,qBAAqB,UAAU,GAAG,CAAC,CAAC;AAE1D,WAAO;AAAA,MACL,MAAM,MAAM;AAAA,MACZ,WAAW;AAAA,IACb;AAAA,EACF;AAEA,QAAM,0BAA0B;AAAA,IAC9B,4BACI,CAAC,uBAA+B;AAC9B,aAAO;AAAA,QACL,KAAK,MAAM,kBAAkB;AAAA,MAC/B;AAAA,IACF,IACA,MAAM,QAAQ,QAAQ,CAAC,CAAC;AAAA,EAC9B;AAEA,WAAS,sBAAsB,QAAiB;AAC9C,UAAM,OAAO,QAAQ;AACrB,UAAM,kBAAkB,YAAY,QAAQ,GAAG;AAC/C,UAAM,cAAoB;AAAA,MACxB,MACE,oBAAoB,SAChBA,WAAU,EAAE,MAAM,iBAAiB,QAAQ,KAAK,GAAG,CAAC,IACpD;AAAA,MACN,CAAC,iBAAiB,KAAK,EAAE;AAAA,IAC3B;AACA,UAAM,EAAE,KAAK,IAAI,cAAc,yBAAyB,aAAa;AAAA,MACnE,8BAA8B;AAAA,IAChC,CAAC;AAED,WAAO;AAAA,EACT;AAEA,QAAM,SAMF;AAAA,IACF;AAAA,IACA,cAAc;AAAA,IAEd;AAAA,IACA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAGA,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,WAAW;AAAA,IAEX;AAAA,IACA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IAEA;AAAA,IAEA;AAAA,IACA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IAEA,UAAU;AAAA,MACR;AAAA,MACA,cAAc;AAAA,MAEd;AAAA,MACA;AAAA,MAEA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MAEA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAGA,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,WAAW;AAAA,MAEX;AAAA,MACA,YAAY;AAAA,MAEZ,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,iBAAiB;AAAA,MACjB,wBAAwB;AAAA,MACxB,UAAU;AAAA,MAEV;AAAA,MAEA,YAAY;AAAA,MACZ,SAAS;AAAA,MAET;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,iBAMF;AAAA,IACF,GAAG;AAAA,IACH,8BAA8B,8BAA8B;AAAA,IAC5D;AAAA,EACF;AAEA,SAAO;AACT;;;AH9mCA,SAAS,WAAAC,gBAAe;AAbxB,YAAY,UAAU,aAAa,UAAU;","names":["makeEventSource","stringify","React","useSyncExternalStoreWithSelector","React","useCallback","useEffect","useCallback","useEffect","useRef","useSyncExternalStore","subscribe","getSnapshot","useRef","useCallback","useEffect","React","manager","useSyncExternalStore","useEffect","options","useCallback","useEffect","useRef","useState","useCallback","useEffect","useMemo","useRef","useSyncExternalStore","useState","useMemo","cacheItem","subscribe","useCallback","useSyncExternalStore","useRef","useEffect","state","useEffect","useRef","noop","useSyncExternalStore","useSyncExternalStoreWithSelector","makeEventSource","options","room","subscribe","getSnapshot","other","rootOrNull","stringify","shallow"]}